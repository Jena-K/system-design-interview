**🔗 [질문 목록](https://github.com/devyuseon/system-design-interview/blob/main/week1/%EC%9C%A0%EC%84%A0.md#%EC%A7%88%EB%AC%B8)**

# 단일 서버

![](https://github.com/devyuseon/system-design-interview/assets/67352902/3a56b326-117d-40a0-ab3c-f7704d6ea841)

1. 사용자는 도메인 이름으로 웹사이트에 접속하고, DNS 서버를 거쳐 ip주소가 반환된다.
2. 해당 IP주소로 HTTP요청이 전달된다.
3. 요청받은 웹 서버가 HTML페이지나 JSON 형태의 응답을 반환한다.

# 데이터베이스

사용자가 늘면 서버 하나로는 힘들다. HTTP 요청을 처리하는 서버와 데이터베이스 서버를 분리해 독립적으로 확장해 나갈 수 있다.

<img width="592" alt="image" src="https://github.com/devyuseon/system-design-interview/assets/67352902/98f92e87-16b7-4cd9-9e1a-6f687afa232e">

## 어떤 데이터베이스를 사용할 것인가?

### RDBMS vs NoSQL

**📍 RDBMS: 관계형 데이터베이스**
- 자료를 열, 칼럼으로 표현
- 테이블 관계를 join하여 합칠 수 있다
- MySQL, 오라클, PostgreSQL 등

**📍 NoSQL: 비 관계형 데이터베이스**
- CouchDB, Neo4j, Cassandra, HBase, Amazon DynamoDB
- 종류
  - key-value store
  - graph store
  - column store
  - document store

#### NoSQL이 적합한 때

- very low latency 요구될때
- 다루는 데이터가 비정형 데이터
- 단순히 데이터를 직렬화/역직렬화 하기 위함
- 대량의 데이터 저장

## 수직적 규모 확장 vs 수평적 규모 확장

`Scale Up`은 서버에 CPU나 RAM등을 추가하는 것, `Scale Out`은 더 많은 서버를 추가해 성능을 개선하는 것이다.

- 수직적 규모 확장에는 한계가 있다.
- 수직적 규모 확장법은 failover, 다중화가 되지 않아 서버 하나가 장애가 나면 아예 서비스 장애가 됨

이런 이유에서 대규모 시스템을 설계할때에는 `Scale Out`이 적절하다.<br/>
위의 설계에서 웹서버 하나가 다운되거나 트래픽이 몰려 응답시간이 느려지면 서버 접속이 불가능해진다.<br/>
이럴때 **로드밸런서**를 도입한다.

## 로드밸런서

<img width="600" alt="image" src="https://github.com/devyuseon/system-design-interview/assets/67352902/b799224f-fa61-41ae-8d8a-cd80f73b3cba">

- 사용자는 Public IP로 접속한다.
- 서버간 통신은 Private IP로 통신한다.

서버가 하나 다운되었을때, 다른 서버가 대체하면 되고, 두 서버가 트래픽을 분산할 수 있다. 더 확장하고 싶다면 서버만 한대 추가하면 된다.

하지만 데이터베이스 서버는 아직 failover나 다중화를 지원하지 않는다.

## 데이터베이스 다중화

### Master-Slave 모델

- 데이터 원본은 Master 서버에, 사본은 Slave 서버에
- 쓰기 연산은 Master 서버에서만 지원
  - 예를들어 insert, delete, update 명령어 
- Slave 서버는 그 사본을 전달받고, 읽기 연산만 지원
- 보통의 어플리케이션은 읽기 연산이 많아 Slave 서버를 많이 둠

**📍 데이터베이스 다중화 성능적 이점**

- 더 나은 성능
- 안전성
- 가용성

<img width="495" alt="image" src="https://github.com/devyuseon/system-design-interview/assets/67352902/af91b085-030c-485b-b748-01fde7fab57f">

이 그림에서, 부 서버가 다운되면 주 서버로 읽기 연산이 전달되고, 다른 부 서버가 장애서버를 대체한다.
주 버서가 다운되면 부 서버가 주 서버를 대신한다. **하지만** 부 서버의 데이터가 최신임은 보장할 수 없다.
없는 데이터는 복구 스크립트를 돌려야 한다. 다중 마스터나 원형 다중화 방식을 도입할 수 있다.

<img width="608" alt="image" src="https://github.com/devyuseon/system-design-interview/assets/67352902/f1577e2e-3f8d-4e4a-9f95-b34281b0e0b3">

로드벨런서와 데이터베이스 다중화까지 한 모습이다.

# 캐시

## 캐시 계층

<img width="598" alt="image" src="https://github.com/devyuseon/system-design-interview/assets/67352902/6a11cb74-3f55-4dc9-8ab8-68c0eae16458">

별도의 캐시 서버를 두면 데이터베이스 부하를 줄이고, 데이터베이스보다 훨씬 빠르게 응답할 수 있다.

> **주도형 캐시 전략**
> 1. 캐시 확인
> 2. 있으면 캐시의 데이터 응답
> 3. 없으면 캐시에 저장하고 응답

## 캐시 사용시 유의할 점

- 캐시가 바람직한 상황인가?
  - 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어날 때
- 어떤 데이터를 캐시에 두어야 하는가?
  - 영속적으로 보관할 데이터를 캐시에 두는 것은 옳지 않다.
- 일관성(데이터 저장소의 원본과 캐시 내의 사본이 같음)이 유지되는가?
- 캐시서버를 한대만 두는 경우 해당 서버가 **단일 장애 지점(Single Point of Failure, SPOF)**이 되어 버릴 가능성이 있다.
- 캐시 메모리를 얼마나 크게 잡을 것인가?
  - 가장 좋은 방법은 캐시 메모리를 과할당
- 캐시가 차면 어떤 데이터를 내보낼 것인가?
  - LRU
  - LFU
  - FIFO

## CDN

request path, query string, cookie, request header에 기반해 HTML 페이지를 캐싱하는 것

**📍 CDN 이용 시 고려해야 할 사항**

- 비용
  - 데이터 전송양에 따라 요금 부과 
  - 자주 사용되지 않는 콘텐츠는 CDN에서 빼자
- 적절한 만료 시한 설정
- CDN 장애에 대한 대처 방안
- 콘텐츠 무효화
  - 아직 만료되지 않은 콘텐츠라도 CDN에서 제거

## Stateless

웹 계층을 수평적으로 확장하려면 상태 정보(세션같은) 를 웹계층에서 제거해야 한다. 상태 정보를 RDB나 NoSQL같은 지속성 저장소에 보관하고 필요할때 가져오는것이 **무상태** 웹계층이라 부른다.

### 상태 정보 의존적 아키텍처

상태정보를 유지하려고 sticky-session 방식을 사용하면 로드밸런서에 부담을 주게 된다. 로드밸런서 뒷단에 서버를 추가하거나, 제거하기도 까다롭다. 장애 처리도 복잡하다.

### 무상태 아키텍처

<img width="577" alt="image" src="https://github.com/devyuseon/system-design-interview/assets/67352902/2a313025-2d28-4e70-b85e-3240ec6a5024">

이 그림에선 상태 정보를 NoSQL에 저장한다. 이러한 무상태 아키텍처를 가졌을때 단순하고, 안정적이며, 규모 확장이 쉽다.

## 데이터 센터

<img width="589" alt="image" src="https://github.com/devyuseon/system-design-interview/assets/67352902/7fccd9f4-ecbc-4acd-83f5-1d14f71b5980">

지리적 라우팅을 통해 데이터센터를 여러개 두어 가장 가까운 데이터센터로 사용자를 안내할 수 있다. 데이터센터중 하나에 장애가 발생할 경우
장애가 없는 데이터 센터로 모든 데이터가 이동된다.

### 기술적 난제

- 트레픽 우회
- 데이터 동기화
  - 장애가 나 트래픽이 다른 데이터센터로 모두 갈때, 해당 데이터센터에 원래 연결하던 데이터센터에 있던 데이터가 없을 수 있다.
  - 데이터를 여러 데이터센터에 걸쳐 다중화 해야 한다.
- 테스트와 배포

시스템을 더 큰 규모로 확장하기 위해선 컴포넌트를 분리해 독립적으로 확장할 수 있어야 한다. **메시지 큐**가 많은 분산시스템이 이 문제를 풀기위해서 채택하고 있는 방법이다.

## 메시지 큐

메시지의 무손실 (메시지큐에 일단 보관된 메시지는 소비자가 꺼낼 때까지 안전하게 보관)을 보장하는 비동기 통신을 지원하는 컴포넌트.<br/>
메시지의 버퍼 역할을 하며, 비동기로 전송한다.

> **메시지 큐의 기본 아키텍처**<br/>
> 1. producer 또는 publisher라 불리는 입력 서비스가 메시지를 만들어 메시지 큐에 발행(publish)한다.
> 2. consumer 혹은 subscriber라 불리는 서비스 혹은 서버가 메시지를 받아 그게 맞는 동작을 수행한다.

### 이점

- 서버간 결합이 느슨해진다.
- 규모 확장성이 보장되어야 하는 안정적 애플리케이션 구성 가능하다.
- 생산자는 소비자 프로세스가 다운되어 있어도 메시지를 발행할 수 있다.
- 소비자는 생성자 서비스가 가용한 상테가 아니어도 메시지를 수행할 수 있다.
  
## 로그, 메트릭 그리고 자동화

- 로그: 로그를 단일서비스로 모아주는 도구가 있으면 좋다.
- 메트릭: 메트릭을 잘 수집하면 사업 현황에 대한 유용한 정보나, 현재 시스템 정보를 손쉽게 파악할 수 있다.
- 자동화: CI를 도와주는 도구를 활용하면 개발 생산성을 크게 향상시킬 수 있다.

## 데이터베이스 규모 확장

수직적 확장은 한계도 있고, 비용도 많이 들고, 위험성이 크다.

### 수평적 확장

**샤딩(sharding)** 이라고도 한다. 대규모 데이터베이스를 샤드라 불리는 작은 단위로 분할하는 기술이다. 모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복이 없다.

#### 샤딩 키 정하기

샤딩 전략을 구현할 때 고려해야할 가장 중요한 사항이다.

- 샤딩 키 == 파티션 키
- 데이터가 어떻게 분산될 지 정하는 하나 이상의 칼럼으로 구성된다.
- 샤딩 키를 통해 올바른 데이터베이스에 쿼리를 보내 데이터 조회나 변경을 처리하므로 효율을 높일 수 있다.

#### 샤딩 도입할때 주의할 점

- 데이터의 재 샤딩
  1. 데이터가 너무 많아져 하나의 샤드로는 감당하지 못할 때
  2. 샤드 간 데이터 분포가 균등하지 못해 어떤 샤드에 할당된 공간 소모가 다른 샤드에 비해 빨리 진행될 때(샤드 소진), 샤드 키를 계산하는 함수를 변경하고 재배치
  -> 안정 해시 기법 활용
- 유명인사 문제
  - 핫스팟 키 라고도 부른다.
  - 특정 샤드에 쿼리가 집중됨
- 조인과 비정규화
  - 여러 샤드에 걸쳐 데이터베이스를 조인하기 어렵다.
  - 데이터를 비정규화해 하나의 테이블에서 쿼리가 수행될 수 있도록 하는 방법이 있다.

# 질문

- 메시지 큐가 다운되면 어떻게 되는가? (p.25 그림에서)
- sticky session이 로드밸런서에게 과부하를 주는 이유는 로드밸런서가 접속 정보를 저장하고 있어서 인가? (p.18)
  - 로드밸런서가 sticky session을 유지해주는 기간을 얼마일까?
  - 내부적으론 어떻게 구현되어 있을까?
- NoSQL이 규모 확장이 간편한 이유는? (p.19 7줄)
