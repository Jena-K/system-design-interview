![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/1bbdacbe-7e19-4bc7-84c4-d350761cb71c)![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/51817bbb-21d9-4714-bdd8-da201efc3950)
# 7장 분산 시스템을 위한 유일 ID 생성기 설계
보통의 유일 ID라고 한다면 관계형 데이터베이스의 auto_increment가 보편적이지만, 분산 환경의 데이터베이스의 경우엔 지연시간을 낮추기 어렵고 
한대의 경우에는 요구를 감당하기 어렵다는 단점이 있다.

## 문제 이해 및 설계 범위 확정

만약에 요구사항이 이렇게 들어온다고 가정해보자
* ID는 유일해야 한다
* ID는 숫자로만 구성되어야 한다
* ID는 64비트로 표현할 수 있는 값이여야 한다.
* ID는 발급 날짜에 따라 정렬 가능해야 한다.
* 초당 10,000개의 ID를 만들 수 있어야 한다.

## 개략적 설계안 제시 및 동의 구하기

### 다중 마스터 복제
![image](https://github.com/frost0807/system-design-interview/assets/98132695/c6c4626d-61bf-4907-9b62-d59f3673fc7d)
다음 ID값을 구할 때, 1만큼 증가시키는게 아니라 k(데이터베이스 서버의 수) 만큼 증가시킨다.
* 단점
  * 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다
  * ID의 유일성은 보장되지만 그 값이 시간흐름에 맞추어 커지도록 보장할 수는 없다.
  * 서버를 추가하거나 삭제할때 잘 동작하기 힘들다.


### UUID
UUID는 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트 짜리의 수이다.
* 장점
  * UUID를 만드는 것이 단순하며 서버와 조율할 필요가 없어 동기화 이슈도 없다.
  * 각 서버가 자기가 쓸 ID를 알아서 만들기 떄문에 규모 확장에 유리하다.

* 단점
  * ID가 128비트로 긴 편이다.
  * ID를 시간 순으로 정렬할 수 없다
  * ID에 숫자가 아닌 값이 들어갈 수도 있다.

### 티켓 서버
![image](https://github.com/frost0807/system-design-interview/assets/98132695/af268c80-2c4d-4a60-8154-f15528466c84)
auto_increment를 갖춘 데이터베이스를 서버를 티켓서버로 만들어 하나의 중앙 집중형으로 사용한다.

* 장점
  * 유일성이 보장되는 오직 숫자로만 구성된 ID를 만들 수 있다.
  * 구현하기 쉽고 중소 규모의 애플리케이션에게 적합하다.
* 단점
  * 타켓서버의 중요도가 너무 올라간다(SPOF). 장애가 발생 시 모든 서버가 영향을 받는다.

### 트위터 스노플레이크 접근법
트위터는 스노플레이크라고 부르는 독창적인 ID 생성 기법을 사용한 접근법이다.

이 접근법을 사용하면  ID를 바로 생성하는게 아니라 분할정복을 사용해 생성해야하는 ID의 구조를 여러 절로 분할한다.
![image](https://github.com/frost0807/system-design-interview/assets/98132695/a458b36d-7794-4362-8cbe-f15384a9e7e3)

* 사인 비트 : 1비트를 할당한다. 음수와 양수를 구분하는데 사용될 수 있다.
* 타임스탬프 : 41비트를 할당한다. epoch 이후로 몇 밀리초 경과 했는지의 시계열 값을 숫자로서 표현될 값이다.
* 데이터센터 ID : 5비트를 할당한다. 따라서 2^5 = 32개 데이터센터를 지원할 수 있다.
* 서버 ID :  5비트를 할당한다. 따라서 데이터 센터당 32개의 서버를 운용할 수 있다.
* 일련번호 : 12비트를 할당한다. 각 서버에서 ID를 생성할 때마다 이 값을 1씩 증가시킨다. 1 밀리초가 경과할 때마다 0으로 초기화된다.

타임스탬프는 41비트로 표현하는데 이는 대략 69년까지 표시할 수 있다. 따라서 69년동안만 작동하기 때문에 그 이후부턴 기원 시각을 바꾸거나 ID체계를 바꿔야한다.
일련번호는 12비트기 때문에, 2^12 = 4096개의 값을 가질 수 있다. 특정 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값을 갖게 된다.

### 마무리 
위에 조건을 다 만족하면서 독립성을 유지하는 ID생성법은 스노 플레이크 방식이다.
하지만 스노플레이크에는 추가적으로 살펴볼 주제가 있다.

* 시계 동기화 : 서버가 물리적으로 여러 곳에 있는 등 같은 시계가 아닐 수 있기 때문에 이를 동기화해주는 "네트워크 타임 프로토콜" 이 필요하다.
* 스노우 플레이크 각 섹션의 최적화 : 동시성이 낮고 수명이 긴 애플리케이션이라면 일련번호를 줄이고 타임스탬프의 절을 늘리는것이 효율적이다.

# 8장 URL 단축기 설계

## 1단계 문제 이해 및 설계 범위 확정
만약에 요구사항이 이렇게 들어온다고 가정해보자
* URL 단축
* URL 리디렉션(축약된 URL로 HTTP 요청이 들어올 경우 원래 URL로 안내하는 것)
* 높은 가용성과 규모 확장성 , 장애 감내

개략적 추정
* 쓰기 연산: 매일 1억개의 단축 URL 생성
* 초당 쓰기 연산: 1160
* 읽기 연산: 초당 11,600회
* 축약 전 URL의 평균길이 100
* 10년동안 필요한 저장공간 3650억


## 2단계 개략적 설계안 제시 및 동의 구하기

### API 엔드포인트
클라이언트는 서버가 제공하는 API 엔드포인트를 통해 서버와 통신한다. 따라서 엔드포인트를 REST 스타일로 설계할 것이다.
1. URL 단축용 엔드 포인트 : 새 단축 URL을 생성하고자 하는 클라이언트는 이 엔드포인트에 단축할 URL을 인자로 실어 POST 요청을 보내야한다.
```  POST/api/vi/data/shorten ```

2. URL 리디렉션용 엔드포인트: 단축 URL에 대해서 HTTP 요청이 오면 원래 URL로 보내주기 위한 용도의 엔드포인트
```  GET/api/vi/shortURL ```
   
### URL 리디렉션
다음 그림은 브라우저에 단축 URL을 입력하면 무슨 일이 생기는지 보여준다.
![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/f0afca77-398f-4b66-bb36-ebf9aa9ec9ea)

단축 URL을 받은 서버는 그 URL을 원래 URL로 바꾸어서 301응답의 Location 헤더에 넣어 반환한다.

다음 그림은 클라이언트와 서버 사이의 통신 절차를 좀 더 자세하게 보여준다.
![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/c8ab771d-28b4-4637-82b5-6204aa3fbe04)

* 301 Permanently Moved: 이 응답은 해당 URL에 대한 HTTP 요청의 처리 책임이 영구적으로 Location 헤더에 반환된 URL로 이전되었다는 응답
  영구적으로 이전되었기 때문에 브라우저는 이 응답을 캐시한다. 따라서 추후 같은 단축 URL에 요청을 보낼 필요가 있을 때 브라우저는 캐시된 원래 URL로   요청을 보낸다

* 302 Found: 이 응답은 주어진 URL 요청이 '일시적으로' Location 헤더가 지정하는 URL에 의해 처리되어야한다는 응답
  따라서 클라이언트의 요청은 언제나 단축 URL 서버에 보내진 후 원래 URL로 리디렉션된다.

장단점: 서버부하를 줄이는 데에는 301이 유리, 하지만 트래픽 분석이 중요할때는 302 를 쓰는것이 클릭발생률이나 발생 위치를 추적하는데 더 유리

URL 리디렉션을 구현하는데 가장 직관적인 방법은 해시테이블을 사용하는 것 해시테이블에 <단축 URL, 원래 URL> 쌍을 저장한다 가정하면 URL 리디렉션은 아래와 같이 구성된다

* 원래 URL= hashTable.get(단축 URL)
* 301 or 302 응답 Location 헤더에 원래 URL 넣은 후 전송

### URL 단축
가장 중요한 것은 URL을 이 해시 값으로 대응시킬 해시 함수 fx를 찾는 일이다.
![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/c8cd654c-44f1-4cc0-99da-74fc65cbf39d)

* 입력으로 주어지는 긴 URL이 다른 값이면 해시 값도 달라진다
* 계산된 해시 값은 원래 입력으로 주어졌던 긴 URL로 복원될 수 있어야한다.

## 3단계 상세 설계

### 데이터 모델
모든 것을 해시 테이블에 둔다면 초기 전략으로는 괜찮지만 메모리는 유한한데다가 비싸기 때문에 실제 시스템에 구현하긴 어렵다.
더 나은 방법으로는 <단축 URL, 원래 URL>의 순서쌍을 관계형 데이터베이스에 저장하는 것
![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/a681897d-492f-4f83-9bf5-46ba22f2f788)

### 해시 함수
해시 함수는 원래 URL을 단축 URL로 변환하는 데 쓰인다.

#### 해시 값 길이
hashValue는 [0-9, a-z, A-Z]의 문자들로 구성된다. 따라서 사용할 수 있는 문자의 개수는 10+26+26 = 62개다. hashValue의 길이를 정하기 위해서는 62^n >= 3650억인 n의 최솟값을 찾아야 한다. 개략적으로 계산했던 추정치에 따르면 이 시스템은 3650억 개의 URL을 만들어 낼 수 있어야 한다.
다음 표는 hashValue의 길이와, 해시 함수가 만들 수 있는 URL 개수 사이의 관계를 나타낸다.
![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/62b4817b-dc76-4e41-8c1e-6410e6c31f66)

n=7이면, 3.5조 개의 URL을 만들 수 있다. 요구사항을 만족시키기 충분한 값이기에 hashValue의 길이는 7로 가정한다.
해시 함수 구현에 쓰일 기술로 두 가지 방법을 살펴본다. 하나는 '해시 후 충돌 해소' 방법이고, 다른 하나는 'base-62 변환법'이다.

#### 해시 후 충돌 해소 
긴 URL을 줄이려면, 원래 URL을 7글자 문자열로 줄이는 해시 함수가 필요하다. 손쉬운 방법은 CRC32, MD5, SHA-1 같이 잘 알려진 해시 함수를 이용하는 것이다. 이들 함수를 사용하여 'https:/en.wikipedia.org/wiki/Systems_design'을 축약한 결과는 다음과 같다.
![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/42da379d-f8d1-4e0c-a5a3-a62814ca3c4b)

하지만 CRC32가 계산한 값은 가장 짧은 해시값조차도 7보다 긴데 이를 해결하고자 한다면 계싼된 해시 값에서 처음 7개 글자만 이용하는 것이다.
다만 이 방법은 해시 결과가 서로 충돌할 확률이 높아진다. 충돌이 실제로 발생한다면 충돌이 해소될 때까지 사전에 정한 문자열을 해시값에 덧붙힌다.

![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/08404c41-9595-4aa8-a123-d21b808c84f9)

이 방법을 쓰면 충돌은 해소할 수 있지만 단축 URL을 생성할 때 한 번 이상 데이터베이스 질의를 해야 하므로 오버헤드가 크다. 데이터베이스 대신 블룸 필터를 사용하면 성능을 높일 수 있다. 블룸 필터는 어떤 집합에 특정 원소가 있는지 검사할 수 있도록 하는, 확률론에 기초한 공간 효율이 좋은 기술이다.

#### base-62 변환
진법 변환(base conversion)은 URL 단축키를 구현할 때 흔히 사용되는 접근법 중 하나다. 이 기법은 수의 표현 방식이 다른 두 시스템이 같은 수를 공유해야 하는 경우에 유용하다. 62진법을 쓰는 이유는 hashValue에 사용할 수 있는 문자의 개수가 62개이기 때문이다.

#### 두 접근법의 비교 
![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/fd05639b-5000-416c-964b-d2f540da4611)


### URL 단축기 상세 설계
URL 단축기는 시스템의 핵심 컴포넌트이므로, 그 처리 흐름이 논리적으로는 단순해야 하고 기능적으로는 언제나 동작하는 상태로 유지되어야 한다. 다음 그림은 62진법 변환 기법을 이용한 처리 흐름을 순서도 형태로 정리한 그림이다.

![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/6635d779-9e68-48c7-b523-1fe5a84aa32a)

1. 입력으로 긴 URL을 받는다.
2. 데이터베이스에 해당 URL이 있는지 검사한다.
3. 데이터베이스에 있다면 해당 URL에 대한 단축 URL을 만든 적이 있는 것이다. 따라서 데이터베이스에서 해당 단축 URL을 가져와서 클라이언트에게 반환한다.
4. 데이터베이스에 없는 경우에는 해당 URL은 새로 접수된 것이므로 유일한 ID를 생성한다. 이 ID는 데이터베이스의 기본 키로 사용된다.
5. 62진법 변환을 적용하여 ID를 단축 URL로 만든다.
6. ID, 단축 UR, 원래 URL로 새 데이터베이스 레코드를 만든 후 단축 URL을 클라이언트에게 전달한다.


만약 입력된 URL이 'https://en.wikipedia.org/wiki/Systems_design'이라고 하자.
* 이 URL에 대해 ID 생성기가 반환한 ID는 2009215674938이다.
* 이 ID를 62진수로 변환하면 zn9edcu를 얻는다.
* 아래 표와 같은 새로운 데이터베이스 레코드를 만든다.

ID 생성기의 주된 용도는, 단축 URL을 만들 때 사용할 ID를 만드는 것이고, 이 ID는 전역적 유일성(globally unique)이 보장되는 것이어야 한다.
고도로 분산된 환경에서 이런 생성기를 만드는 것은 무척 어려운 일이다. 다만 전 장에서 분산 ID 생성기에 대해서 공부했으므로 복습하는 것을 추천

### URL 리디렉션 상세 설계
다음 그림은 URL 리다이렉션 메커니즘의 상세한 설계를 그리고 있다.
쓰기보다 읽기를 더 자주 하는 시스템이라, <단축 URL, 원래 URL>의 쌍을 캐시에 저장하여 성능을 높였다.

![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/a648c98f-62be-4086-ad7e-d6ff1d80395a)

로드밸런서의 동작 흐름은 다음과 같이 요약할 수 있다.

1. 사용자가 단축 URL을 클릭한다.
2. 로드밸런서가 해당 클릭으로 발생한 요청을 웹 서버에 전달한다.
3. 단축 URL이 이미 캐시에 있는 경우에는 원래 URL을 바로 꺼내서 클라이언트에게 전달한다.
4. 캐시에 해당 단축 URL이 없는 경우에는 데이터베이스에서 꺼낸다. 데이터베이스에 없다면 아마 사용자가 잘못된 단축 URL을 입력한 경우일 것이다.
5. 데이터베이스에서 꺼낸 URL을 캐시에 넣은 후 사용자에게 반환한다.


### 마무리 
* 처리율 제한 장치(rate limiter)
 * 지금까지 살펴본 시스템은 엄청난 양의 URL 단축 요청이 있을 경우 무력화될 수 있다는 잠재적 보안 결함을 갖고 있다. 처리율 제한 장치를 두면, IP 주소를 비롯한 필터링 규칙들을 이용해 요청을 걸러낼 수 있을 것이다.
웹 서버의 규모 확장
 * 본 설계에 포함된 웹 계층은 무상태 계층이므로, 웹 서버를 자유롭게 증설하거나 삭제할 수 있다.

* 데이터베이스의 규모 확장
 * 데이터베이스를 다중화하거나 샤딩(sharding)하여 규모 확장성을 달성할 수 있다.

* 데이터 분석 솔루션(analytics)
 * 성공적인 비즈니스를 위해서는 데이터가 중요하다. URL 단축기에 데이터 분석 솔루션을 통합해 두면 어떤 링크를 얼마나 많은 사용자가 클릭했는지, 언제 주로 클릭했는지 등 중요한 정보를 알아낼 수 있을 것이다.

* 가용성, 데이터 일관성, 안정성
 * 대규모 시스템이 성공적으로 운영되기 위해서는 반드시 갖추어야 할 속성들이다.

