# 단일 서버

웹 앱, 데이터베이스, 캐시 등이 서버 한 대에서 실행된다.

1.  사용자는 도메인 이름으로 DNS를 통해 IP주소로 변환한다.
2.  DNS 조회로 IP주소가 반환된다.
3.  IP주소로 HTTP 요청을 전달한다.
4.  HTML이나 JSON 형태로 응답한다.
</br>

# 데이터 베이스

사용자가 늘게 되면 서버를 여러대 두어야 한다. 하나는 웹/모바일 트래픽 처리용, 하나는 데티어베이스용이다.    
</br>



   

## 어떤 데이터베이스를 사용할 것인가?

관계형 데이터베이스

```
- MySQL, 오라클, PostgreSQL 등   
- 자료를 테이블과 열, 칼럼으로 표현   
- 조인할 수 있음   
```



비 관계형 데이터베이스

```
- Cassandra, HBase, Amazon DynamoDB 등   
- 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소로 나뉨   
- 조인 지원 안 함   
- 낮은 응답 latency   
- 데이터가 비정형이라서 관계형 데이터가 아님   
- 아주 많은 양의 데이터 저장 
```
</br>

# 수직적 규모 확장 vs 수평적 규모 확장

수직적 규모 확장(scale up)은 고사양 자원을 추가하는 행위를 말한다. 트래픽 양이 적을때 좋고 단순하다.  
그러나 한계가 있으며 자동 복구(failover)나 다중화(redundancy) 방안이 없다. 서버에 장애가 발생할 시에 웹 사이트와 앱은 중단된다.

반면에, 수평적 규모 확장(scale out)은 서버를 추가하여 성능을 개선한다. 대규모 애플리케이션 지원시에는 이 방법이 좋다.

사용자가 웹 서버로 바로 연결 시에 서버가 다운되면 엡사이트에 접속할 수 없다. 또한 사용자가 집중될 때 응답 속도가 느려지거나 접속이 불가할 수 있을때, **로드밸런서**를 도입하는 것이 최선이다.
</br>

# 로드밸런서

트래픽 부하를 고르게 분산하는 역할을 한다. http 통신에서 DNS을 통해 IP주소를 직접 접근하지 않고 로드밸런서를 중간에 놓는다. 웹 서버는 클라이언트의 접속을 직접 처리하지 않는다. 사용자는 로드밸런서를 통해 **공개 IP 주소**로 접근하고, 서버 간 통신에는 **사설 IP 주소**가 이용된다.

부하 분산 집합에 웹 서버를 추가하면 자동 복구(failover)문제와 가용성이 향상된다.
</br>

# 데이터베이스 다중화

서버 사이에 주(master)-부(slave) 관계를 설정하고 쓰기연산은 마스터에서 지원한다. 이를 복사하여 부 데이터베이스는 읽기 연산을 할 수 있다.

데이터베이스를 다중화하게 되면 성능이 좋아진다.

1.  성능 : 병렬 처리 할 수 있는 쿼리가 많아지기 때문이다.
2.  안정성(realiability): 데이터베이스 중 일부가 파괴되어도 데이터는 보존될 것이다.
3.  가용성(availability): 하나의 데이터베이스가 장애가 생겨도 계속 서비스할 수 있다.

데이터베이스 서버 가운데 하나가 다운되도 즉시 대체될 수 있게 설계되어 있다.
</br>

# 캐시

응답 시간을 개선할 수 있는 저장소이다. 값이 비싼 연산 결과나 자주 참조되는 데이터를 메모리에 두고 빨리 처리할 수 있게 한다. 데이터가 잠시 보관되는 곳으로 성능이 개선되고 데이터베이스의 부하를 줄이고, 캐시 계층의 규모를 독립적으로 확장시킬 수 있다.
</br>

## 캐시 사용시 유의할 점

1.  어떤 상황에 쓸 것인지?: 데이터 갱신율이 적고 참조가 자주 일어나는 데이터
2.  어떤 데이터를 쓸지?: 휘발성 메모리이므로 중요 데이터는 지속적인 저장소에 넣어야 한다.
3.  어떻게 만료할지?: 정책을 미리 고민할 필요가 있다.
4.  일관성(Consistency): 단일 트랜잭션으로 처리하지 않을 경우 일관성이 깨질 수 있다. 시스템 확장시 일관성 유지가 문제가 된다.
5.  장애 대처: 캐시 서버를 한 대만 둘 경우 SPOF가 될 수 있다. 따라서 여러 지역에 캐시 서버를 분산시켜야 한다.
6.  캐시 메모리 크기: 너무 작으면 eviction으로 캐시 성능 저하가 된다. 캐시 메모리 과할당(overprovision)으로 해결할 수 있다.
7.  eviction 정책은 무엇인가?: 캐시 용량이 찰 경우 데이터를 내보내야 하는데 LRU, LFU, FIFO 등이 있다.
</br>

# CDN

CDN은 정적 콘텐츠를 전송하는 데 쓰인다. 지리적으로 분산된 서버 네트워크이다.


## CDN 사용 시 고려해야 할 사항

1.  비용: CDN은 3rd party에 의해 운영되어 데이터 전송 양에 따라 요금을 부과한다.
2.  만료 시한 설정: time-sensitive 콘텐츠를 판단하여 만료 시점을 설정한다.
3.  CDN 장애 대처 방안; CDN이 죽었을 경우 웹 사이트와 애플리케이션의 대처 방안을 세운다.
4.  콘텐츠 무효화(invalidation): CDN 서비스에서 제공하는 API, 오브젝트 버저닝을 통해 바꾼다.
</br>

# 무상태(Stateless) 계층

웹 계층을 **수평적**으로 확장한다.상태 정보를 저장소에 보관하게 된다.

## 상태 정보 의존적인 아키텍처

상태 정보를 보관하는 서버는 클라이언트 정보를 요청 사이에 공유하도록 하지만, 무상태 서버는 그런 정보가 없다. 그렇기에 HTTP 요청 받을 시 어떤 웹 서버로 전송될 수 있고, 공유 저장소에서 정보를 가져와서 확인할 수 있다. 단순하고 안정적이며 규모확장이 좋은 장점이 있다.

그림 1-14에서 세션 데이터를 지속성 데이터 보관서에 저장하게 설계되었다.가용성을 높여 전 세계에서 웹 사이트를 쾌적하게 사용하기 위해서는 **데이터 센터**의 역할이 중요하다.

## 데이터 센터

장애가 없는 상태에서 사용자는 웹 사이트에 접근 시 geo-routing을 통해 가까운 데이터 센터에서 서버의 라우팅이 된다.

다중 데이터센터 아키텍처 설계시 고려해야 할 사항

1.  트래픽 우회:올바른 데이터 센터로 트래픽을 보내야 한다.
2.  데이터 동기화: 데이터 센터마다 별도의 데이터베이스를 사용하면 장애가 자동 복구(failover)되어 트래픽이 다른 데이터베이스로 우회더라도 해당 데이터 센터에 데이터가 없을 수 있다.
4.  deployment: 웹 사이트 또는 애플리케이션을 여러 위치에서 테스트 해보는 것이 중요하다.
</br>
시스템을 큰 규모로 확장하기 위해서는 컴포넌트로 분리하여 독립적으로 확장할 수 있어야 한다. **메시지 큐**가 해결 방안이 될 수 있다.
</br>


# 메시지 큐
 메시지의 무손실(durability)을 보장하는 비동기 통신 지원 컴포넌트이다.메시지의 버퍼역할을 하며, 비동기적으로 전송한다.     
 생산자/발행자가 메시지를 만들어 메시지 큐에 발행(publish)하면, 큐에 연결된 소비자/구독자가 수행한다.   
 서버간의 결합을 느슨하게 하고 규모 확장성이 보장되는 곳에 구성하기 좋다.   
 시스템의 규모를 확장하기 위해서는 컴포넌트를 분리하여 독립적으로 확장할 수 있어야 한다. 
 
 </br>


# 로그, 메트릭 그리고 자동화
    
    1.  로그: 에러 로그를 모니터링 하는 것이 중요하다. 오류를 쉽게 찾을 수 있기 때문이다. 서버 단위로 모니터링할 수 있고 3rd party에서 제공하는 단일 서비스로 모아주는 도구를 활용하는 방안도 있다.
    2.  메트릭: 사업 현황에 관한 정보를 얻을 수 있고 시스템의 현재 상태를 쉽게 파악할 수 있다.
    
    -   호스트 단위 메트릭: CPU, Memory, Disk I/O에 관한 메트릭
    -   핵심 비지니스 메트릭: 일별 능동 사용자, 수익, 재방문
    -   자동화: 생산성을 높이기 위해 활용해야 한다. 이 외에도 빌드, 테스트, 배포 등 절차를 자동화할 수 있어 개발 생산성을 향상시킬 수 있다.   

    
</br>

# 데이터베이스의 규모 확장

## 수직적 확장

스케일 업이라고 부른다. 고성능의 자원(CPU, RAM 등)을 증설하는 방법이다.

\-> 사용자가 늘면 감당하기 어렵다.  
\-> SPOF 위험성  
\-> 비용

## 수평적 확장

 샤딩(sharding)이라고 부른다. 더 많은 서버를 추가하여 성능을 향상시킨다.  
 모든 shard는 같은 스키마를 쓰지만 샤드에 보관되는 데이터는 중복이 없다.   
 샤딩 전략을 구현할 때 **샤딩 키**를 정하는 것이 가장 중점이다. **파티션 키**라고도 불린다.   
 데이터가 어떻게 분산될 지 정하는 칼럼으로 구성되므로 샤딩 키를 정할 때는 데이터를 고르게 분할할 수 있도록 해야 한다.   
 
 
 샤딩을 도입할 경우 직면할 문제도 있다.
 1. 데이터의 재 샤딩(resharding):
    <br>
     (1) 데이터가 많아졌을 때,
    <br>
     (2) 샤드 간 데이터 분포가 균등하지 않아 공간 소모가 빠를 때 (shard exhaustion),
    <br>
         샤드 키를 계산하는 함수를 변경하고 데이터를 재배치 해야 한다. **안정 해시**로 해결할 수 있다.   
 3. Celebrity 문제:
    <br>
     **핫스팟 키** 문제라고도 한다. 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제다.
    <br>  
     각 유명인사에 샤드 하나를 더 할당 하거나 쪼개는 방식으로 해결한다.
    <br>
     혹은, 최적의 샤드 키를 사용하여 데이터를 고르게 분산한다.
 5. join and de-normalization: 샤드를 쪼개면 데이터를 조인하기 어려워 진다.   
 							   이는 데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행할 수 있도록 해결한다.
                               
  
 </br>
 
 # 요약
 
 - Stateless 계층으로   
 - 모든 계층에 다중화   
 - 가능한 많은 데이터를 캐시할 것   
 - 데이터 센터를 많이 분산시킬 것   
 - CDN을 통해 서비스 제공할 것   
 - 데이터 계층은 샤딩을 통해 규모 확장할 것   
 - 각 계층은 독립적 서비스로 분할할 것   
 - 시스템을 지속적으로 모니터링하고, 자동화 도구를 활용할 것

<br>

# 질문
- Stateless한 HTTP 에서 로그인을 어떻게 구현할까?
- 로드밸런서는 scale up의 방안이 될 수도 있을까?


***
# 링크
* 참조
  <br>
  Alex Xu, (2021). _가상 면접 사례로 배우는 대규모 시스템 설계 기초_, 인사이트
  <br>
  [동적 콘텐츠 캐싱](http://aws.amazon.com/cloudfront/dynamic-content/)
  <br>
  [Stateless 계층](https://www.redhat.com/en/topics/cloud-native-apps/stateful-vs-stateles)
  <br>
  [메시지 큐](https://www.ibm.com/kr-ko/topics/message-queues)
  <br>
  [데이터베이스 샤딩](https://aws.amazon.com/ko/what-is/database-sharding/)
 
