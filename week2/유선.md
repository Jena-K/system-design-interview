# 목차

<!-- TOC -->
* [2장 개략적인 규모 측정](#2장-개략적인-규모-측정)
  * [2의 제곱수](#2의-제곱수)
  * [응답 지연 값](#응답-지연-값)
  * [가용성과 관계된 수치](#가용성과-관계된-수치)
  * [트위터 QPS 예제](#트위터-qps-예제)
* [4장 처리율 제한 장치의 설계](#4장-처리율-제한-장치의-설계)
  * [처리율 제한 장치란?](#처리율-제한-장치란)
  * [처리율 제한 장치가 필요한 이유](#처리율-제한-장치가-필요한-이유)
  * [처리율 제한 장치는 어디에 둘 것인가?](#처리율-제한-장치는-어디에-둘-것인가)
  * [처리율 제한 알고리즘](#처리율-제한-알고리즘)
    * [Token Bucket (토큰 버킷)](#token-bucket-토큰-버킷)
    * [Leaky Bucket (누출 버킷)](#leaky-bucket-누출-버킷)
    * [Fixed window counter (고정 윈도 카운터)](#fixed-window-counter-고정-윈도-카운터)
    * [Sliding window log (이동 윈도 로그)](#sliding-window-log-이동-윈도-로그)
    * [Sliding window counter (이동 윈도 카운터)](#sliding-window-counter-이동-윈도-카운터)
  * [Redis](#redis)
  * [처리율 한도 초과 트래픽 처리](#처리율-한도-초과-트래픽-처리)
  * [분산 환경에서의 처리율 장치 구현](#분산-환경에서의-처리율-장치-구현)
    * [경쟁 조건](#경쟁-조건)
  * [동기화 이슈](#동기화-이슈)
* [질문](#질문)
<!-- TOC -->

# 2장 개략적인 규모 측정

## 2의 제곱수

- 최소 단위는 1바이트, 8비트
- ASCII 문자 하나는 1바이트

|2^ |근사치|축약형|
|--|--|--|
|10|1천|1KB|
|20|1백만|1MB|
|30|10억|1GB|
|40|1조|1TB|
|50|1000조|1PB|

## 응답 지연 값

<img width="587" alt="image" src="https://github.com/devyuseon/system-design-interview/assets/67352902/d749d6f2-52e8-40cf-8be8-80263de32ba0">

- 메모리는 빠르지만 디스크는 느리다
- 디스크 탐색(seek)는 피하라
- 단순한 압축 알고리즘은 빠르다 (zippy)
- 데이터를 인터넷으로 전송하기 전에 가능하면 압축하라.
- 데이터 센터는 보통 여러 지역에 분산되어 있고, 센터들 간에 데이터를 주고 받는 데는 시간이 걸린다.

## 가용성과 관계된 수치

보통은 99% ~ 100% 사이. 9가 많을수록 좋다.

![image](https://github.com/devyuseon/system-design-interview/assets/67352902/48fc3d21-e9c4-493e-8d0a-3007e8fa2bce)

## 트위터 QPS 예제

# 4장 처리율 제한 장치의 설계

## 처리율 제한 장치란?

클라이언트 또는 서비스가 보내는 트리픽의 처리율(rate)를 제어하기 위한 장치. HTTP를 예로 들면 특정 기간 내에 전송되는 클라이언트의 요청 횟수를 제한

## 처리율 제한 장치가 필요한 이유

- DoS 공격에 의한 자원 고갈 방지
- 비용 절감. 추가 요청에 대한 처리를 제한하므로 서버를 많이 두지 않아도 된다.
- 서버 과부하 방지

## 처리율 제한 장치는 어디에 둘 것인가?

- 클라이언트: 클라이언트 요청은 쉽게 위변조가 가능해 처리율 제한을 위한 장치를 둘 곳으론 부적절하다.
- 서버: API 서버쪽에 두거나, 미들웨어를 두어 처리율 제한을 구현할 수 있다. MSA의 경우, 보통 API Gateway라 불리는 컴포넌트에 구현된다.
  - 서버쪽에서 구현한다면 필요한 알고리즘을 선택하여 구현할 수 있다.
  - API Gateway는 보통 제 3사업자가 제공하는 것을 사용하는데, 이럴 경우 선택지는 제한될 수 있다.

## 처리율 제한 알고리즘

### Token Bucket (토큰 버킷)

<img width="581" alt="image" src="https://github.com/devyuseon/system-design-interview/assets/67352902/ea45056a-d128-4c32-9272-7461a80d8aa3">


- 토큰 버킷은 지정된 용량을 갖는 컨테이너
- 이 버킷에는 사전 설정된 양의 토큰이 주기적으로 채워진다.
- 각 요청은 처리될 때마다 하나의 토큰을 사용하며, 충분한 토큰이 없다면 해당 요청은 버려진다.

**장점**

- 구현이 쉽다
- 메모리 사용 측면에서도 효율적
- 짧은 시간에 집중되는 트래픽도 처리 가능

**단점**

- 버킷 크기와 토큰 공급률이라는 두개의 인자를 가지고 있는데, 이 값을 적절하게 튜닝하는것은 까다로운 일이다.

### Leaky Bucket (누출 버킷)

<img width="628" alt="image" src="https://github.com/devyuseon/system-design-interview/assets/67352902/d0ac047d-a975-4ae7-bdbe-a0e8871e04a2">

- 토큰 버킷 알고리즘과 비슷하지만 요청 처리율이 고정되어 있다.
- FIFO 큐로 구현한다.
- 요청이 도착하면 큐가 가득차있는지 보고 빈자리가 있다면 큐에 추가한다.
- 큐가 가득 차 있는 경유에는 새 요청은 버려진다.
- 지정된 시간마다 큐에서 요청을 꺼내어 처리한다.

**두 개의 인자**

- 버킷 크기: 큐 사이즈와 같은 값. 큐에는 처리될 항목들이 보관됨
- 처리율: 지정된 시간당 몇 개의 항목을 처리할지 지정. 보통 초단위 지정

**장점**

- 큐의 크기가 제한되어 있어 메모리 사용량 측면에서 효율적
- 고정된 처리율을 갖고 있어 안정적 출력이 필요한 경우 적합

**단점**

- 단시간에 많은 트래픽이 몰리는 경우 큐에는 오래된 요청들이 쌓이게 되고, 그 요청들을 제때 처리 못하면 최신 요청들은 버려진다.
- 두 개의 인자를 갖고 있는데, 이들을 올바르게 튜닝하기가 까다롭다.

### Fixed window counter (고정 윈도 카운터)

<img width="635" alt="image" src="https://github.com/devyuseon/system-design-interview/assets/67352902/62498ac6-6c86-4ec3-bbf5-906497f1f06a">

- 타임라인을 고정된 간격의 윈도로 나누고, 각 윈도마다 카운터를 할당한다.
- 요청이 접수될 때마다 이 카운터의 값은 1 증가한다.
- 이 카운터의 값이 사전에 설정된 임계치에 도달하면 새로운 요청은 새 윈도가 열릴 때까지 버려진다.

**장점**

- 메모리 효율이 좋다.
- 이해하기 쉽다.
- 윈도가 닫히는 시점에 카운터를 초기화 하는 방식은 특정한 트래픽 패턴을 처리하기 적합하다.

**단점**

- 윈도 경계 부근에서 일시적으로 많은 트래픽이 몰리는 경우 기대했던 시스템의 처리 한도보다 많은 양의 요청을 처리하게 된다.

### Sliding window log (이동 윈도 로그)

<img width="502" alt="image" src="https://github.com/devyuseon/system-design-interview/assets/67352902/9c3f9c83-232d-4aa4-9d11-82e64dd57d70">

- 요청의 타임스탬프를 추적한다.
- 타임스탬프 데이터는 보통 Redis의 정렬집합 같은 캐시에 보관한다.
- 새 요청이 오면 만료된 타임스탬프를 제거한다. 만료된 타임스탬프는 그 값이 현재 윈도의 시작 지점보다 오래된 타임스탬프를 말한다.
- 새 요청의 타임스탬프를 로그에 추가한다.
- 로그의 크기가 허용치보다 같거나 크다면 요청을 시스템에 전달하고 그렇지 않은 경우엔 처리를 거부한다.

**장점**

- 어느 순간의 윈도를 보더라도 허용되는 요청의 개수는 시스템의 처리율 한도를 넘지 않는다.

**단점**

- 다량의 메모리를 사용한다. 거부된 타임스탬프도 보관하기 때문이다.

### Sliding window counter (이동 윈도 카운터)

<img width="599" alt="image" src="https://github.com/devyuseon/system-design-interview/assets/67352902/d760cb00-feec-4cdc-a490-c94e4b4e498c">

- 고정 윈도 카운터 알고리즘과 이동 윈도 로깅을 결합한 것

**장점**

- 이전 시간대의 평균 처리율에 따라 현재 윈도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘 대응한다.
- 메모리 효율이 좋다.

**단점**

- 직전 시간대에 도착한 요청이 균등하게 분포되어 있다고 가정한 상태에서 추정치를 계산하기 때문에 다소 느리다.

## Redis

카운터를 보관하는 곳은 데이터베이스로는 부적절하다. 디스크 접근 때문에 느리기 때문이다.<br/>
메모리상에서 동작하는 캐시이고, 만료시간을 설정할 수 있는 Redis를 많이 쓴다.

- INCR: 메모리에 저장된 카운터의 값을 1 증가시킨다.
- EXPIRE: 카운터에 타임아웃 값을 설정한다.

## 처리율 한도 초과 트래픽 처리

예를들어 HTTP 요청은 다음 헤더로 처리율을 표현한다.

- X-Ratelimit-Remaining: 윈도 내 남은 처리 가능 요청 수.
- X-Ratelimit-Limit: 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수.
- X-Ratelimit-After: 한도 제한에 걸리지 않으려면 몇초 뒤에 요청을 보내야 하는지 알림

따라서 처리율을 초과하면 `429 too many reaquests` 오류를 X-Ratelimit-After 헤더와 반환한다.

## 분산 환경에서의 처리율 장치 구현

경쟁조건, 동기화 두가지 문제를 풀어야 한다.

### 경쟁 조건

counter를 동시에 병렬로 읽고, 값을 증가시켜 저장할경우 문제가 된다. 이 경우 널리 알려진 해결책은 **Lock**이다.

하지만 락은 성능을 떨어뜨리므로 대신 사용할 수 있는 해결책은

- 루아(Lua) 스크립트
- 정렬 집합 레디스 자료구조

를 쓰는 것이다.

## 동기화 이슈

- sticky session을 사용한다. 하지만 이는 확장 가능하지도 않고 유연하지 않아 좋지 않다.
- redis와 같은 중앙 집중형 데이터 저장소를 쓰는 것이다.

# 질문

- p.71: sticky session보단 redis와 같은 중앙 집중형 데이터 저장소를 쓰는 것이 더 나은 해결책이라고 하였다. redis가 중앙 집중형 데이터 저장소인가?..
  - 레디스로 여러 서버로 분산한다면 클러스터를 맺어 사용해야 할 것이다.
  - 책에서 중앙 집중형 데이터 저장소라고 표현했는데 어떤 의미에서 이런 용어가 나왔는지? 
