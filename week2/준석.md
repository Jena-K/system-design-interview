## 2장

### 개략적인 규모 측정

- 보편적으로 사용되는 성능 수치 항목들을 추정해서 계산하는 것
- 필요한 기본기로 2의 제곱수나 응답지연(latency) 값과 가용성에 관계된 수치들의 이해가 있어야 한다.

2의 제곱수
응답지연 값
가용성에 관계된 수치들

### 2의 제곱수

- 데이터 볼륨 단위를 계산하기 위해 사용 (양을 측정) 최소단위는 1바이트(8비트) 이다.
- 아스키 문자 하나가 차지하는 메모리의 크기가 1바이트 이고 보통 많이 사용되는 UTF-8의 경우 1~4 바이트가 사용된다.
- 한글 또는 다국어를 고려할 때 한 단어를 4바이트 까지 고려하는 것이 좋겠다.
- 책에서는 페타바이트 까지 나와 있는데 이는 2의 50제곱으로 약 1000조 바이트이다.
- 대략 많이 사용되는 기가바이트는 약 10억 으로 2의 30제곱이다.

### 응답지연 값

| 연산명                                                  | 시간              |
| ------------------------------------------------------- | ----------------- |
| 뮤텍스 락/언락                                          | 100ns             |
| 주 메모리 참조                                          | 100ns             |
| Zippy로 1KB 압축                                        | 10us              |
| 1Gbps 네트워크로 2KB 전송                               | 20,000ns = 10us   |
| 메모리에서 1MB 순차적으로 read                          | 500,000ns = 250us |
| 디스크 탐색                                             | 10ms              |
| 네트워크에서 1MB 순차적으로 read                        | 10ms              |
| 디스크에서 1MB 순차적으로 read                          | 30ms              |
| 한 패킷의 캘리포니아로부터 네델란드까지의 왕복 지연시간 | 150ms             |

### 결론

- 메모리는 빠르지만 디스크는 아직도 느리다.
- 디스크 탐색은 가능한 피하라.
- 단순한 압축 알고리즘은 빠르다.
- 데이터를 인터넷으로 전송하기 전에 가능하면 압축
- 데이터 센터는 보통 여러 지역에 분산되어 있고 센터들 간에 데이터를 주고받는데는 시간이 걸린다.

### 가용성에 관계된 수치들

- 가용시간은 관습적으로 숫자 9를 사용해 표시
  |가용률 시간 |하루당 장애 시간 |연간 장애시간|
  | 99%| 14.40분| 3.65일|
  |99.9% |1.44분| 8.77시간|
  |99.99% |8.64초| 52.60분|
  |99.999% |864.00밀리초| 5.26분|

#### 고가용성

- 시스템이 오랜 시간 동안 지속적으로 중단 없이 운영될 수 있는 능력을 지칭하는 용어다.
- 100%는 시스템이 단 한 번도 중단된 적이 없었음을 의미한다.

### 트위터 QPS와 저장소 요구량 추정

#### 가정

- 월간 능동 사용자는 3억 명이다
- 50%의 사용자가 트위터를 매일 사용한다
- 평균적으로 각 사용자는 매일 2건의 트윗을 올린다
- 미디어를 포함하는 트윗은 10% 정도다
- 데이터는 5년간 보관된다

### 추정

- 월간 능동 사용자는 3억 명이다
- 50%의 사용자가 트위터를 매일 사용한다
- 3억 \* 50% = 1.5억 명

### QPS(Query Per Second) 추정치

- 평균적으로 각 사용자는 매일 2건의 트윗을 올린다
- QPS = 1.5억 \* 2 트윗 / 24시간 / 1분(3600초) = 약 3500
- 최대 QPS = 3500 \* 2 = 약 7000

### 미디어 저장을 위한 저장소 요구량

- 평균 트윗 크기(avg)

tweet_id 에 64바이트
텍스트에 140바이트
미디어에 1MB

- 미디어를 포함하는 트윗은 10% 정도다
- 1.5억 2(개) 10% \* 1MB = 30TB/일

- 데이터는 5년간 보관된다
- 30TB 365일 5년 = 약 55PB

### 팁

개략적인 규모 추정과 관계된 면접에서 가장 중요한 것은 문제를 풀어 나가는 절차다.

올바른 절차를 밟느냐가 결과를 내는 것보다 중요하다. 면접자가 보고 싶어하는 것은 문제 해결 능력이다.

- 근사치를 사용한 계산을 할줄 알아야 한다. 즉 반올림, 올림, 내림에 대한 오차 수준을 생각해서 근사치로 계산시간을 줄인다.
- 가정은 적어 둬라 위에도 적혀 있다.
- 단위를 붙이는 습관을 둬라 이건 꼼꼼함을 챙기는 포인트로 보인다 개발자는 꼼꼼함도 중요하다.
- QPS, TPS, 저장소량, 캐시 요구량, 서버 수 등 추정하는 방법을 미리 연습해 두어라.

#### Java의 문자열 계산 수치 (utf-8 기준)

- 영문, 숫자, 특수기호는 1byte
- 한글은 3byte로 계산

---

## 4장

### API 처리 장치의 장점

- DoS (Denial of Service) 공격 방지
- 비용 절감
- 서버 과부하를 막는다.

### 1단계 문제 이해 및 설계 범위 확정

#### 요구사항

- 설정된 처리율을 초과하는 요청은 정확하게 제한한다
- 낮은 응답시간 : 이 처리율 제한 장치는 HTTP 응답시간에 나쁜 영향을 주어서는 곤란하다.
- 적은 메모리
- 분산형 처리율 제한 : 하나의 처리율 제한 장치를 여러 서버나 프로세스에 공유할 수 있어야 한다.
- 예외 처리 : 요청이 제한되었을 때는 그 사실을 사용자에게 분명하게 보여주어야 한다.
- 높은 결함 감내성 : 제한 장치에 장애가 생기더라도 전체 시스템에 영향을 주어서는 안 된다.

### 2단계 개략적 설계안 제시 및 동의 구하기

#### 처리율 장치의 위치

- 클라이언트 측

위변조가 가능하여 권장하지 않는다.

- 서버 측

중앙화해서 관리한다.

- 미들웨어

MSA 인 경우, 처리율 제한 장치는 보통 API Gateway 에 구현한다.

API Gateway: 처리율 제한, SSL 종단, 사용자 인증, IP 허용 목록 관리 등

#### 요약하면

- 현재 기술 스택이 서버 측에 기능 구현이 가능한지 점검
- 상황에 맞는 알고리즘 사용, 만약 제3 사업자가 제공하는 API Gateway 를 사용한다면 선택지는 제한이 될 수 있다.
- MSA 에 기반하고 있다면 인증, IP 허용 같은 기능을 이미 API Gateway 에 적용했을 수 있다. 그러면 처리율 제한도 API Gateway 에 포함하는 것이 좋다.
- 충분한 인력이 없다면 상용 솔루션도 고려해보는 것이 좋다.

#### 가능한 알고리즘

#### 토큰 버킷 알고리즘

- 토큰이 주기적으로 채워진다.
- 각 요청이 처리될 때마다 하나의 토큰을 사용한다.
- 토큰이 없다면 해당 요청은 버려진다.

- 많은 기업들이 보편적으로 사용하는 알고리즘
- 통상적으로 API 엔드포인트마다 별도의 버킷을 둔다.
- IP 주소별로 처리율 제한을 적용해야 한다면 IP 주소마다 버킷을 하나씩 할당해야 한다.
- 시스템의 처리율을 초당 10,000 개 요청으로 제한한다면, 모든 요청이 하나의 버킷을 공유하도록 해야 한다.

#### 장점

- 구현이 쉬움
- 메모리 효율적
- 짧은 시간에 집중 되는 트래픽도 잘 처리

#### 단점

- 버킷 크기 & 토큰 공급률 두 개의 인자를 필요로하는 알고리즘이기 때문에 적절하게 튜닝하는 것이 어렵다.

#### 누출 버킷 알고리즘

- 요청이 들어오면 큐가 가득 차 있는지 체크한다.
- 빈 자리가 있다면 큐에 요청을 추가한다.
- 만약 큐가 가득 차 있다면 요청은 버린다.
- 지정된 시간마다 큐에서 요청을 꺼내어 처리한다.
- 토큰 버킷 알고리즘과 비슷하지만, 요청 처리율이 고정되어 있다는 점이 다르다.

큐에서 1초에 1개씩 꺼내!

- 보통 FIFO 큐로 구현한다.

#### 장점

- 큐의 크기 제한 -> 메모리 효율적 사용
- 고정된 처리율을 가지고 있어 안정적 출력 (stable outflow rate) 이 필요한 경우 적합

#### 단점

- 단기간에 많은 트래픽이 몰리는 경우 최신 요청들이 버려지게 될 수 있음
- 토큰 버킷 알고리즘처럼 튜닝이 어렵다. (버킷 크기 & 처리율)

#### 고정 윈도 카운터 알고리즘

- 타임라인을 고정된 간격의 window 로 나누고, 각 윈도우마다 카운터를 붙인다.
- 요청 접수 -> 카운터 + 1
- 카운터가 임게치에 도달하면 새로운 요청은 버려진다.

#### 장점

- 메모리 효율이 좋다.
- 이해하기 쉽다.
- Window 가 닫히는 시점에 카운터를 초기화하는 방식은 특정한 트래픽 패턴을 처리하기에 적합하다.

#### 단점

- Window 경계 부근에 트래픽이 몰리면 설정한 임게치를 초과할 수 있다.

#### 이동 윈도 로깅 알고리즘

- 타임스탬프를 추적하는 알고리즘이다.
- 타임스탬프 데이터는 보통 레디스의 sorted set 같은 캐시에 보관
- 새 요청이 오면 만료된 타임스탬프는 제거
- 로그의 크기가 허용치보다 같거나 작으면 시스템에 전달
- 허용치보다 크면 처리 거부

#### 장점

- 처리율 제한 메커니즘이 매우 정교하다.
- 어느 순간의 윈도를 보더라도 처리율 한도를 넘지 않는다.

#### 단점

- 거부된 요청의 타임스탬프도 보관하기 때문에 메모리를 많이 사용한다.
