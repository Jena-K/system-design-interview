![image](https://github.com/user-attachments/assets/491258dc-6517-464c-95f7-7369f6b2c0e7)
# 11장 뉴스 피드 시스템 설계
페이스북의 도움말 페이지에서 설명하는 뉴스피드란 여러분의 홈 페이지 중앙에서 지속적으로 업데이트 되는 스토리들로 사용자 상태 정보 업데이트, 사진, 비디어, 링크, 앱 활동, 
그리고 여러분이 페이스북에서 팔로하는 사람들, 페이지, 또는 그룹으로부터 나오는 '좋아요' 등 을 포함하는 것이라고 한다.
뉴스 피드 설계는 아주 유명한 면접 문제로 페이스북, 인스타그램, 트위터 설계 하는 법을 알아야한다.

## 1단계 문제 이해 및 설계 범위 확정
가장 먼저 해야할 일은 면접관의 의도를 파악하는 것으로 질문을 통해 알아내면 된다 책에서의 설계 예시는 이렇다.
* 모바일 앱 or 웹 or 둘 다 지원? => 둘 다 지원
* 중요한 기능? => 사용자는 뉴스 페이지에 새로운 스토리를 올리고 친구들이 올리는 스토리를 볼 수 있다.
* 뉴스 피드는 어떤 순서로 스토리가 표시되는가? => 단순한 시간 흐름 역순
* 한 명의 사용자는 최대 몇 명의 친구? => 5,000
* 트래픽 규모는? => 매일 천만 명 방문
* 피드에 이미지나 비디오? => 파일 포함 가능

## 2단계 개략적 설계안 제시 및 동의 구하기
살펴볼 설계안은 두가지 이다.
* 피드 발행 : 사용자가 스토리를 포스팅하면 해당 데이터를 캐시와 데이터베이스에 기록하고 새 포스팅은 친구의 뉴스 피드에 전송된다.
* 뉴스 피드 생성 : 지면 관계상 뉴스 피드는 모든 친구의 포스팅을 시간 흐름역순으로 모아서 만든다.

### 뉴스 피드 API
뉴스 피드 API는 클라이언트가 서버와 통신하기 위해 사용하는 수단이다. HTTP 프로토콜 기반이고 상태 정보를 업데이트 하거나
뉴스 피드를 가져오거나 친구를 추가하는 등 다양한 작업을 수행하는데 사용된다. 

#### 피드 발행 API
새 스토리를 포스팅하기 위한 API이다. HTTP POST 형태로 요청을 보내면 된다. 
```
POST/v1/me/feed
```

여기서 인자는 포스팅 내용에 해당하는 바디와 API 호출을 인증하기 위한 Authorization 헤더가 있다.

#### 피드 읽기 API
뉴스 피드를 가져오는 API이다. 
```
GET/v1/me/feed
```

여기서 인자는 API 호출을 인증하기 위한 Authorization 헤더가 있다.

#### 피드 발행
피드 발행의 개략적 형태는 다음과 같다.
![image](https://github.com/user-attachments/assets/12a9d9d5-d3ed-4fc5-aa7d-ca23efb003b2)


* 사용자 : 모바일 웹이나 브라우저에서 새 포스팅을 올리는 주체이다. POST/v1/me/feed API를 사용한다.
* 로드밸런서: 트래픽을 웹 서버들로 분산한다.
* 웹 서버: HTTP 요청을 내부 서비스로 중개하는 역할을 담당한다.
* 포스팅 저장 서비스: 새 포스팅을 데이터베이스와 캐시에 저장한다.
* 포스팅 전송 서비스: 새 포스팅을 친구의 뉴스 피드에 푸시한다. 뉴스 피드 데이터는 캐시에 보관해 빠르게 읽을 수 있게한다.
* 알림 서비스: 친구들에게 새 포스팅이 올라왔을때 알려주거나 푸시 알림을 보내는 역할을 담당한다.

#### 뉴스 피드 생성
뉴스 피드가 어떻게 만들어지는지에 대한 개략적 설계안
![image](https://github.com/user-attachments/assets/56a25bd8-5a26-497c-aef6-697fd21c4c29)

* 사용자: 뉴스 피드를 읽는 주체이다 GET/v1/me/feed API를 이용한다.
* 로드 밸런서: 트래픽을 웹 서버에 분산한다.
* 웹 서버 : 트래픽을 뉴스 피드 서비스로 보낸다.
* 뉴스 피드 서비스: 캐시에서 뉴스 피드를 가져오는 서비스이다
* 뉴스 피드 캐시: 뉴스 피드를 렌더링할 때 필요한 피드 ID를 보관한다.

## 3단계 상세 설계
지금까지 뉴스 피드 발행과 생성의 두 가지 흐름이 포함된 개략적 설계안을 보았다면 이제 이 두 가지 부분의 설계를 보다 상세히 하겠다.![image](https://github.com/user-attachments/assets/86f63b96-aa8b-4d18-a0df-e13eacad5187)

#### 피드 발행 흐름 상세 설계
웹 서버와 포스팅 전송 서비스에 좀 더 초점을 두었다.

#### 웹 서버
웹 서버는 클라이언트와 통신할 뿐 아니라 인증이나 처리율 제한 등의 기능도 수행한다. 올바른 인증 토큰을 Authorization 헤더에 넣고 API를 호출하는 사용자만 포스팅 할 수 있어야한다. 또한 스팸을 막고 유해한 콘텐츠가 자주 오르는 것을 방지하기 위해 특정 기간동안 한 사용자가 올릴 수 있는
포스팅 수에 제한을 둔다.

#### 포스팅 전송 서비스
포스팅 전송 즉 팬아웃은 어떤 사용자가 새 포스팅을 그 사용자와 친구 관계에 있는 모든 사용자에게 전달하는 과정이다. 팬아웃에는 두가지 모델이 있다.
* 쓰기 시점에 포스팅 전송하는 Push 모델:새로운 포스팅을 기록하는 시점에 뉴스피드를 갱신한다.
  장점
  > 뉴스 피드가 실시간으로 갱신되며 친구 목록에 있는 사용자에게 즉시 전송된다.
  > 포스팅이 쓰이는 시점에 전송되므로 뉴스 피드를 읽는 데 드는 시간이 짧아진다.
  단점
  > 친구가 많은 사용자의 경우 뉴스 피드 갱신에 많은 시간이 소요될 수 있다.(핫키 이슈)
  > 사용자의 친구 목록에 있는 사용자의 피드를 모두 갱신하므로 서비스를 자주 이용하지 않는 사용자의 피드까지 갱신된다. 따라서 컴퓨팅 자원이 낭비된다.
* 읽기 시점에 포스팅 전송하는 Pull 모델:피드를 읽어야 하는 시점에 뉴스 피드를 갱신한다.
  장점
  > 로그인하지 않은(비활성화된 사용자) 또는 서비스를 자주 이용하지 않는 사용자에게 피드가 갱신되지 않으므로 컴퓨팅 자원을 아낄 수 있다.
  > 데이터를 친구 목록의 사용자 모두에게 푸시하는 작업이 필요 없으므로 핫키 문제도 발생하지 않는다.
  단점
  > 뉴스 피드를 읽는데 많은 시간이 소요될 수 있다.

  * 두가지 모델 결합법
대부분의 사용자에게선 뉴스 피드를 빠르게 가져오기 위해 push 모델을 사용하지만 친구나 팔로어가 아주 많은 사용자의 경우에는 팔로어로 하여금 해당 사용자의 포스팅이 필요할 때 가져가도록 하는 pull 모델을 사용하여 시스템 과부하를 방지한다. 아울러 안정 해시를 통해 요청과 데이터를 고르게 분산해 핫키 문제를 최대한 방지한다.

#### 피드 읽기 흐름 상세 설계
![image](https://github.com/user-attachments/assets/ff2e1ba8-72ec-4be5-95b3-9eb3e24945d6)
1. 사용자가 뉴스 피드를 읽으려는 요청을 보낸다 요청은 /v1/me/feed 로 전송
2. 로드 밸런서가 요청을 웹 서버 가운데 하나로 보낸다.
3. 웹 서버는 피드를 가져오기 위해 뉴스 피드 서비스를 호출한다.
4. 뉴스 피드 서비스는 뉴스 피드 캐시에서 포스팅 ID 목록을 가져온다
5. 뉴스 피드에 표시할 사용자 이름, 사용자 사진, 포스팅 콘텐츠, 이미지 등을 사용자 캐시와 포스팅 캐시에서 가져와 완전한 뉴스 피드를 만든다.
6. 생성된 뉴스 피드를 JSON 형태로 클라이언트에게 보낸다. 클라이언트는 해당 피드를 렌더링한다.

#### 캐시 구조
캐시 구조는 뉴스 피드 시스템의 핵심 컨포넌트로 본 설계안은 캐시를 다섯계층으로 구분한다. 
![image](https://github.com/user-attachments/assets/ac31f59b-70b9-4ca5-8c13-189b57517cc6)

* 뉴스 피드: 뉴스피드의 ID를 보관한다.
* 콘텐츠: 포스팅 데이터를 보관하고 인기 콘텐츠는 따로 보관한다.
* 소셜 그래프: 사용자 간 관계 정보를 보관한다. (팔로워, 팔로잉)
* 행동: ‘좋아요’나 댓글 같은 사용자 행위에 관한 정보를 보관한다.
* 횟수: ‘좋아요’ 횟수, 응답 수, 팔로워 수, 팔로잉 수 등의 정보를 보관한다.

## 4단계 마무리
데이터 베이스 규모 확장
* 수직적 규모 확장 vs 수평적 규모 확장
* SQL vs NoSQL
* 주-부 데이터베이스 다중화
* 복제본에 대한 읽기 연산
* 일관성 모델
* 데이터베이스 샤딩

이 외에도 아래와 같이 더 논의해보면 좋을 주제들이 있다.

* 웹 계층을 무상태로 운영하기
* 가능한 한 많은 데이터를 캐시할 방법
* 여러 데이터 센터를 지원할 방법
* 메시지 큐를 사용하여 컴포넌트 사이의 결합도 낮추기
* 핵심 메트릭에 대한 모니터링.
* 트래픽이 몰리는 시간대의 QPS, 사용자 피드를 새로고침할 때의 지연시간


# 12장 채팅 시스템 설계 
채팅 앱이라고 했을 때, 사람들이 떠올리는 것은 제각각이다. 그러나 요구사항은 확실히 하는 것이 중요하다.

## 1단계 문제 이해 및 설계 범위 확정
페이스북, 메신저, 위챗, 왓츠앱처럼 1:1 채팅에 집중하는 앱들이 있는가 하면 슬랙과 같이 그룹 채팅에 중점을 둔 업무용 앱도 있다. 게임 채팅에 쓰이는 디스코드같이 대규모 그룹의 소통과 응답지연이 낮은 음성채팅에 집중하는 앱도 있기 때문에
이 단게에서는 면접관에게 원하는 앱이 무엇인지 정확히 알아내야한다. 책에서의 설계 예시는 이렇다.
* 1:1 채팅 vs 그룹 채팅앱? => 둘 다 지원
* 모바일 웹 vs 웹&앱 => 둘 다 지원
* 트래픽 규모는? => 일별 능동 사용자 수 기준으로 5천만명을 처리 할 수 있어야 한다.
* 그룹 채팅 인원 제한? => 최대 100명까지
* 중요 기능 => 1:1채팅 ,그룹 채팅, 사용자 접속상태 표시 지원 텍스트만 주고받음
* 메세지 길이 제한? => 100,000자 이하
* 종단 간 암호화를 지원해야하는지? => 아직은 생각 없음
* 채팅 이력 보관 기간 => 영원히

이 요구사항을 정리하자면 아래와 같다.
* 응답지연이 낮은 일대일 채팅 기능
* 최대 100명까지 참여할 수 있는 그룹 채팅 기능
* 사용자의 접속상태 표시 기능
* 다양한 단말 지원, 하나의 계정으로 여러 단말에 동시 접속 지원
* 푸시 알림

## 2단계 개략적 설계안 제시 및 동의 구하기
채팅 서비스가 갖춰야 할 기본 기능은 아래와 같다.

* 클라이언트들로부터 메시지 수신
* 메시지 수신자 결정 및 전달
* 수신자가 접속 상태가 아닌 경우 접속할 때까지 보관
![image](https://github.com/user-attachments/assets/7c30c3c1-c1aa-4619-a389-bb59bc0c2c7e)
채팅 서비스의 경우 어떤 통신 프로토콜을 사용할 것인지가 굉장히 중요한 요소이다.
위 그림에서는 클라이언트가 채팅 서비스에 HTTP 프로토콜로 연결한 다음 메시지를 보내어 수신자에게 해당 메시지를 전달하라고 알린다.

이때 keep-alive 헤더를 사용해 클라이언트-서버 사이의 연결을 끊지 않고 계속 유지하도록 하면 핸드셰이크 횟수를 줄일 수 있어 효율적이다. 하지만 메시지 수신 시나리오는 이것보다 복잡하고 서버에서 클라이언트로 임의 시점에 메시지를 보내는데 쉽게 쓰일 수 없는 문제가 존재한다. 따라서 이를 해결하기 위해 폴링, 롱 폴링, 웹소켓 등 다양한 기법들이 제안되어 왔다.

### 폴링
폴링 기법은 클라이언트가 주기적으로 서버에게 새 메시지가 있는지 확인하는 방법이다.
주기적으로 확인하는 방법이기 때문에 서버에서 답해줄 메시지가 없는 경우 서버 자원이 불필요하게 낭비된다.
![image](https://github.com/user-attachments/assets/98602608-81bd-465e-81f7-5975b0fc406c)

### 롱 폴링
롱 폴링은 폴링의 비효율적인 부분을 개선한 기법이다.
![image](https://github.com/user-attachments/assets/afcc5a7c-2cab-4a28-8731-21d898663aa3)

### 웹 소켓
웹소켓은 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술이다.

### 개략적 설게안
웹 소켓을 프로토콜로 사용하기로 결정했으니 이제 무상태 서비스, 상태 유지 서비스, 제3자 서비스 연동으로 나누어 전체 시스템의 개략적인 설계를 해보자.

#### 무상태 서비스
무상태 서비스는 로그인, 회원가입, 사용자 프로필 표시 등을 처리하는 전통적인 요청/응답 서비스로 로드밸런서 뒤에 위치한다.
![image](https://github.com/user-attachments/assets/4b24a451-bd7e-4895-b4ba-f764f4c3f8cf)

#### 상태 유지 서비스
채팅 서비스는 각 클라이언트가 채팅 서버와 독립적인 네트워크 연결을 유지해야 한다. 따라서 상태 유지 서비스가 필요하게 된다. 클라이언트는 일반적으로 서버가 살아 있는 한 다른 서버로 연결을 변경하지 않기 때문에 특정 서버에 부하가 몰리지 않도록 서비스 탐색 서비스와 긴밀한 협력을 하게 된다.

#### 제 3자 서비스 연동
채팅 서비스에서 새 메시지를 받은 경우 푸시 알림은 필수적으로 필요하다. 이는 앱이 실행중이 않더라도 알림을 받아야 하므로 채팅 서비스와 푸시 알림 서비스의 통합은 매우 중요하다. 이 부분이 궁금하다면 알림 시스템 설계를 참고하자.

#### 규모 확장성
채팅 서비스가 커지면 대량의 트래픽 처리는 필수적이므로 규모 확장성이 중요한 요소로 작용한다.
계속해서 살펴봤던 규모 확장성의 개념을 도입하면 다음과 같은 구조를 개략적으로 설계할 수 있다.

![image](https://github.com/user-attachments/assets/6d41656c-35ee-4c5f-a17a-a0ac945ed1a0)
실시간으로 메시지를 주고받기 위해 클라이언트는 채팅 서버와 웹소켓 연결을 끊지 않고 유지한다.

* 채팅 서버는 클라이언트 사이에서 메시지를 중계하는 역할을 담당한다.
* 접속 상태 서버는 사용자의 접속 여부를 관리한다.
* API 서버는 로그인, 회원가입 등 나머지 전부를 처리한다.
* 알림 서버는 푸시 알림을 담당한다.
* 키-값 저장소는 채팅 이력을 보관하고 사용자에게 이전 채팅 이력 정보 제공을 담당한다.
 
#### 저장소 
* 사용자 프로필, 설정, 친구 목록과 같은 일반적인 데이터
* 채팅 이력처럼 채팅 시스템에 고유한 데이터
우리는 이 두 개의 데이터 유형과 읽기/쓰기 연산 패턴을 이해하고 저장소를 선택해야 한다.

1번의 경우 데이터 안정성을 보장하는 관계형 데이터베이스가 적합하고
2번은 키-값 저장소와 같은 NoSQL이 유리하다.

채팅 이력 데이터의 양은 엄청나게 많고 최근에 주고받은 메시지가 가장 빈번하게 사용되며, 검색 기능이나 멘션 같은 기능도 잘 지원해야 한다. 키-값 저장소는 수평적 규모 확장이 쉽고, 데이터 접근 지연시간이 낮기 때문에 채팅 이력을 보관하는 저장소로 사용하기에 적합하다.

### 데이터 모델
그렇다면 키-값 저장소에 저장될 메시지 데이터는 어떻게 보관해야 할까?
메시지의 키가 되는 ID, 메시지를 보내는 사람, 받는 사람, 메시지 컨텐츠, 메시지 생성 일자 등이 필요할 것이다.
여기서는 메시지의 ID가 중요하다.

메시지 ID는 고유해야 하며 정렬이 가능해야 한다. 즉, 새로운 ID는 이전 ID보다 큰 값을 가지고 있어야 한다.

가장 적합한 메시지 ID 생성 방법은 몇 가지가 있는데, 첫 번째 방법은 분산 시스템의 유일 ID 생성기 설계에서 살펴본 스노플레이크 같은 전역적 64-bit 순서 번호 생성기를 이용하는 것이고 두 번째 방법은 지역적 순서 번호 생성기를 이용하는 것이다.
여기서 지역적 순서 번호 생성기란 같은 그룹 안에서만 유일성을 보증하는 순서 번호 생성기를 말한다.

## 3단계 상세 설계
상세 설계에서는 채팅 시스템의 중요한 컴포넌트인 서비스 탐색, 메시지 전달 흐름, 사용자 접속 상태 표시하는 방법을 더 자세히 알아보자.

### 서비스 탐색
![image](https://github.com/user-attachments/assets/20874355-9a8d-496b-b395-31d6f750c2f1)
앞서 잠깐 언급했듯 서비스 탐색은 클라이언트에게 가장 적합한 채팅 서버를 추천해준다.
주키퍼로 구현한 서비스 탐색 기능의 동작 방식은 다음과 같다.
1. 사용자가 시스템 로그인을 시도한다.
2. 로드밸런서가 API 서버들 중 하나로 요청을 보낸다.
3. API 서버가 인증 처리를 완료하면 서비스 탐색 기능이 동작하여 최적의 채팅 서버를 찾는다.
4. 사용자는 최적의 채팅 서버로 선택된 채팅 서버 2와 웹소켓 연결을 맺는다.

### 메세지 흐름
#### 1:1 채팅 메시지 처리 흐름
![image](https://github.com/user-attachments/assets/0e3310e9-927e-46ff-8cea-6c3367fb54cf)
1. 사용자 A가 채팅 서버 1로 메시지 전송
2. 채팅 서버 1은 ID 생성기를 사용해 메시지 ID를 결정
3. 해당 메시지를 메시지 동기화 큐로 전송
4. 메시지가 키-값 저장소에 보관됨
5. (a) 사용자 B가 접속 중인 경우 B가 사용 중인 채팅 서버로 메시지 전송 (b) 사용자 B가 접속 중이 아니라면 푸시 알림 서버로 푸시 알림 메시지 전송
6. 사용자 B와 채팅 서버 사이에 연결된 웹소켓을 통해 메시지 전송

#### 여러 단말 사이의 메시지 동기화
![image](https://github.com/user-attachments/assets/0a94c5ea-a7fc-4584-bf23-5a6c912c437e)

#### 소규모 채팅에서의 메시지 흐름
소규모 그룹 채팅을 지원할 때는 다음과 같이 수신자별로 메시지 동기화 큐에 새 메시지를 복사하는 방식을 사용할 수 있다. 아래의 예시는 사용자 A가 B, C에게 새로운 메시지를 전송했을 때 메시지 흐름이다.
![image](https://github.com/user-attachments/assets/c52a13e8-678e-42f9-bf69-4afcf7cf208a)

반대로 그룹 채팅에서 메시지를 수신할 때는 모든 사용자의 메시지를 받을 수 있어야 한다.
![image](https://github.com/user-attachments/assets/b7ae62f4-718d-452e-9cdc-409f7fe3cfaa)

### 접속상태 표시
사용자의 접속 상태 기능은 접속상태 서버를 통해 관리한다.
접속상태 서버는 클라이언트와 웹소켓으로 통신하는 실시간 서비스의 일부이다.

#### 사용자 로그인
클라이언트와 실시간 서비스 사이에 쉡 소켓 연결이 맺어지고 나면 접속 상태 서버는 A의 상태와 last_active_at 타임스템프 값을 키-값 저장소에 보관한다.
이 절차가 끝나고 나면 해당 사용자는 접속 중으로 표시
![image](https://github.com/user-attachments/assets/25e913fc-0d37-4643-b7d3-77403e015112)


#### 로그아웃
키-값 저장소에 보관된 사용자 상태가 online에서 offline으로 바뀌게 된다는 점을 유의해야한다.


#### 접속 장애 
사용자의 인터넷 연결이 끊기면 클라이언트와 서버 사이에 맺어진 웹 소켓 같은 지속적 연결도 끊기게 된다. 따라서 이럴 때 사용자를 오프라인 상태로 표시하고 
연결이 복구되면 온라인상태로 변경하는 간단한 방법이 있다. 하지만 이 방법에는 심각한 문제가 있는데, 짧은 시간 동안 연결이 끊기는 순간은 많은데
이럴 때마다 오프라인으로 변경하면 사용자 경험 측면에서 좋지 않다는 점이다. 
본 설계안에서는 박동검사를 통해 문제를 해결한다. 즉 온라인 상태의 클라이언트로 하여금 주기적으로 박동 이벤트를 접속 상태 서버로 보내주고 마지막 이벤트를 받은 지 
x초 이내로 또 다른 박동 이벤트 메세지를 받게 되면 해당 사용자의 접속상태를 계속 온라인으로 유지하는 것이다. 
![image](https://github.com/user-attachments/assets/31ca6e1d-59b7-4428-b501-87cc85d5c91d)


#### 상태 정보의 전송 
발행-구독 모델을 사용해 각 친구마다 채널을 하나씩 두어 상태 정보 변화를 통지받을 수 있도록 설계하면 쉽게 상태 정보 변화를 전달받을 수 있게 된다.
하지만 이 방법은 소규모 그룹 채팅에 적합하며 대규모 그룹 채팅에는 적합하지 않다.
대규모 그룹 채팅의 경우 너무 많은 이벤트가 발생하기 때문이다.
만약 대규모 그룹 채팅에서 상태 정보를 전달 기능이 필요하다면 입장 순간에만 상태 정보를 읽어가던가, 수동으로 갱신하도록 유도해야 한다.
![image](https://github.com/user-attachments/assets/48787fee-3e09-45ce-9af2-9d2d6e02ab22)


## 4단게 마무리
사진이나 비디오 등의 미디어를 지원하기 위해서는 압축 방식, 클라우드 저장소, 섬네일 생성 등을 고려해볼 수 있다.
종단 간 암호화를 사용해 당사자 외에 아무도 메시지 내용을 볼 수 없게 하여 메시지 전송의 보안을 강화할 수 있다.
읽은 메시지에 대해 캐시를 도입하면 서버와 주고받는 데이터 양을 줄 일 수 있다.
사용자의 데이터, 채널 등을 지역적으로 분산하는 네트워크를 구축하면 로딩 속도를 개선할 수 있다.
