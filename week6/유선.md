# 12장 채팅 시스템 설계

## 요구사항

- 응답지연이 낮은 일대일 채팅 기능
- 최대 100명까지 참여할 수 있는 그룹 채팅 기능
- 사용자의 접속상태 표시 기능
- 다양한 단말 지원. 하나의 계정으로 여러 단말에 동시 접속 지원
- 푸시 알림

## 설계

**송신 클라이언트**

- 오랜 세월 검증된 HTTP 프로토콜 사용
- keep-alive 헤더를 사용해 TCP 접속 과정에서 발생하는 핸드셰이크 횟수를 줄일 수 있다.

**수신 클라이언트**

- 송신 클라이언트 구현보다 복잡하다. 폴링/롱 폴링/웹소켓 등을 생각할 수 있다.

### 폴링

![image](https://velog.velcdn.com/images/ohdowon064/post/a0f620b4-000f-45ea-a102-176c15d55241/image.png)

- 클라이언트가 주기적으로 서버에게 새 메시지가 있느냐고 물어보는 방법
- 답해줄 메시지가 없는 경우 서버 자원이 불필요하게 낭비됨

### 롱 폴링

폴링이 여러모로 비효율적이여서 나온 방법이 롱 폴링이다.

![Untitled](https://velog.velcdn.com/images/ohdowon064/post/0c47849e-5aeb-42ea-89cf-aea442d04340/image.png)

- 클라이언트는 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지한다.
- 클라이언트는 새 메시지를 받으면 기존 연결을 종료하고, 서버에 새로운 요청을 보내어 모든 절차를 다시 시작한다.

**단점**

- 메시지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수 있다.
    - HTTP 서버는 보통 무상태 서버
    - 로드밸런싱을 위해 라운드로빈 알고리즘을 이용하는 경우 메시지를 받은 서버는 해당 메시지를 수신할 클라이언트와 롱 폴링 연결을 가지고 있지 않은 서버일 수 있다.
- 서버 입장에서는 클라이언트가 연결을 해제했는지 아닌지 알 좋은 방법이 없다.
- 여전히 비효율적이다. 메시지를 많이 받지 않는 클라이언트도 타임아웃이 일어날때까지 주기적으로 서버에 접속해야 한다.

### 웹소켓

![Untitled](https://velog.velcdn.com/images/ohdowon064/post/bd27d8c8-6b33-48be-8b54-6abca899d665/image.png)

- 서버가 클라이언트에게 비동기 메시지를 보낼때 가장 널리 사용한다.
- 웹소켓 연결은 클라이언트가 시작하고 양방향이다.
- 처음엔 HTTP 연결, 핸드셰이크를 거쳐 웹소켓 연결이 된다.
- 메시지를 보내고 받을때 같은 프로토콜을 사용해 간단하지만, 연결이 항상 유지되어야 해서 연결 관리를 잘 해야한다.

### 개략적 설계안

![Untitled](https://velog.velcdn.com/images/ohdowon064/post/b58345e2-dcf3-42d1-b6d3-f63cc12a0330/image.png)

채팅을 제외한 기능은 무상태로 구현해도 된다. 채팅 시스템은 세 부분으로 구현할 수 있다.

- stateless(무상태) 서비스
- stateful(상태유지)서비스
- third-party연동

 **stateless 서비스**

- 서비스 탐색
    - 접속할 채팅 서버의 DNS 호스트명을 클라이언트에게 알려주는 역할
- 인증 서비스
- 그룹 관리
- 사용자 프로파일

**stateful 서비스**

- 채팅 서비스
- 한 서버에 부하가 몰리지 않도록 설계한다.

**third-party 연동**

- 푸시 알림 (제10장. 알림 시스템 설계 참고)

### 규모 확장성

![Untitled](https://velog.velcdn.com/images/ohdowon064/post/9606f457-33bf-4fb4-9caf-c23551857bb2/image.png)

- 채팅 서버는 클라이언트 사이에 메시지를 중계하는 역할 담당
- presence server, 접속 상태 서버는 사용자의 접속여부를 관리
- API서버가 로그인, 회원가입, 프로파일 변경등 나머지 전부 관리
- 알림 서버가 푸시알림을 보냄
- 키-값 저장소에는 채팅 이력을 관리

### 저장소

- key point는 RDBMS를 쓸지, NoSQL을 쓸지 선택하는 것
- 데이터 유형, 읽기/쓰기 연산의 패턴 고려
- 두가지 데이터를 다룬다.
    - 사용자 프로파일, 설정, 친구 목록과 같은 일반적인 데이터
        - 안전성 보장을 위해 RDBMS에 보관
        - 다중화(replication), 샤딩(sharding)으로 데이터의 가용성과 규모확장성 보증
    - 채팅 시스템에 고유한 데이터, 채팅 이력
        - 양이 많다.
        - 최근에 주고받은 메시지는 빈번하게 확인하고, 오래된 메시지는 잘 확인하지 않는다.
        - 검색, 언급된 메시지로 이동, 특정 메시지로 점프해 무작위적인 데이터 접근 지원
        - 1:1 채팅의 경우 읽기/쓰기 비율은 1:1정도

채팅 시스템에 고유한 데이터인 채팅 이력을 저장하기 위한 저장소로는 이 책에선 키-값 저장소를 선택했다. 이유는 다음과 같다.

- 키-값 저장소는 규모확장이 쉽다.
- 키-값 저장소는 접근 지연시간(latency)가 낮다.
- 관계형 데이터베이스는 데이터 가운데 롱 테일(long tail)에 해당하는 부분을 잘 처리하지 못하는 경향이 있다. 인덱스가 커지면 데이터에 대한 무작위적 접근(random access)을 처리하는 비용이 늘어난다.
- 페이스북 메신저나 디스코드가 키-값 저장소를 채택했다.
    - 페이스북은 HBase
    - 디스코드는 Cassandra

> long tail이란?
- 파레토 법칙을 그래프에 나타냈을때 꼬리처럼 긴 부분을 형성하는 80%
- 경영학에서 파레토 법칙은 상위 20%의 고객이 매출의 80%를 차지한다는 이론
- 컴퓨터공학에선 20%의 요구사항이 80%의 리소스를 잡아먹는다는 의미
https://en.wikipedia.org/wiki/Long_tail
> 

## 데이터 모델

1:1 채팅을 위한 메시지 테이블

![Untitled](https://velog.velcdn.com/images/ohdowon064/post/b1894b66-a4bf-40ba-848d-ffe94640b94c/image.png)

- message_id가 기본 키
- created_at으로 메시지 순서 정할 수 없음
    - 서로 다른 메시지가 동시에 만들어질 수 있음

그룹 채팅을 위한 메시지 테이블

![Untitled](https://velog.velcdn.com/images/ohdowon064/post/97f15da8-8cf6-4d0e-8141-a5f0adf69924/image.png)

- channel_id, message_id 의 복합키 를 기본키로 사용
- channel_id를 파티션 키로도 사용

메시지ID

- 메시지 순서를 표현할 수 있어야 함
- 고유해야 함
- id는 정렬 가능해야하고 시간순과 일치해야 함
- 방법
    - rdbms라면 auto_increment
    - snowflake
    - local sequence number generator (지역적 순서 번호 생성기)
        - id의 유일성은 그룹 안에서만 보증하면 충분함

## 상세 설계

### 서비스 탐색

클라이언트에게 적합한 채팅 서버 추천

- 클라이언트의 위치
- 서버의 용량

고려한다. 서비스 탐색 기능을 구현하는 데 널리 쓰이는 오픈소스는 아파치 주키퍼가 있다.

> Apache Zookeeper
> - Hadoop(코끼리), Hbase(범고래), Hive(벌) 등 빅데이터 생태계에 동물 이름으로 된 로고가 많은데, 이런 동물들의 사육사, Zookeeper 역할을 한다고 해 붙인 이름
> - 분산 코디네이션 서비스로 활용한다.
>    - 분산 처리 어플리케이션에서 ‘부분 실패’ 처리가 관건인데, 이런 부분 실패를 안전하게 처리할 수 있도록 분산 처리 도구를 제공한다.

## 접속상태 표시

접속 상태 서버 (presencse server) 를 통해 사용자의 상태를 관리한다.

### 사용자 로그인

- 웹소켓 연결이 맺어지면 접속상태 서버는 사용자의 상태와 last_active_at 타임스탬프 값을 키-값 저장소에 보관한다.
- status를 online으로 표시한다.

### 로그아웃

- 키-값 저장소에 status를 offline으로 표시한다.

### 접속 장애

예기치 못하게 연결이 끊어진 경우 오프라인으로 표시해야 한다. heartbeat(박동) 검사로 이를 구현할 수 있다.


# 13장 검색어 자동완성 시스템

## 요구사항
- 빠른 응답 속도
- 연관성
- 정렬
- 규모 확장성
- 고가용성

## 개략적 설계안

### 데이터 수집 서비스

빈도 테이블 등으로 저장한다.

### 질의 서비스

데이터 수집 서비스에서 수집한 질의와 빈도수를 정렬해 5개까지 뽑아낸다. (SQL)

## 상세 설계

### 트라이 자료구조

트라이 자료구조를 이용해 문자들을 저장한다. 질의어를 찾는 과정은 다음과 같다.
1. 접두어 노드 'xx'를 찾는다.
2. 해당 노드부터 시작하는 하위트리를 탐색해 모든 유효 노드를 찾는다.
3. 정렬하여 top n개를 추출한다.

최적화 방안은 다음과 같다.

- 접두어 최대 길이 제한
- 노드에 인기 검색어 캐시
![](https://github.com/sangminlee98/system-design-interview/assets/83197138/a4349c00-1359-418f-ab19-16cb12b8db0e)

### 데이터 수집 서비스

#### 데이터 분석 서비스 로그

질의에 대한 데이터를 로그로 쌓는다. 수정은 되지 않고 추가만 된다.

#### 로그 취합 서버

주기적으로 로그를 취합하며, 어플리케이션 성격에 따라 주기를 다르게 가져간다.

#### 작업 서버

트라이 자료구조를 만들고 트라이 데이터베이스에 저장하는 역할이다.
주기적으로 비동기 job을 수행하는 서버이다.

#### 트라이 캐시

스냅샷을 떠서 읽기 연산 성능을 개선한다.

#### 트라이 데이터베이스

두가지 선택지가 있다.

- 문서(document) 저장소: 주기적으로 직렬화하여 저장한다. MongoDB와 같은 곳에 저장할 수 있다.
- 키-값 저장소
  - 트라이에 보관된 모든 접두어를 해시 테이블 키로 변환
  - 각 트라이 노드에 보관된 모든 데이터를 해시 테이블 값으로 반환
 
#### 트라이 연산 - 검색어 삭제

트라이 캐시 앞에 필터계층을 두어 부적절한 질의어가 반환되지 않도록 한다. 따로 저장해놨다가 다음번 업데이트 사이클에서 물리적으로 삭제할 수 있다.
