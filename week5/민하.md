# 9장 웹 크롤러 설계

크롤러의 이용

-   검색 엔진 인덱싱: 가장 보편적인 용례. 크롤러는 웹페이지를 모아 검색 엔진을 위한 로컬 인덱스를 생성

    (ex. 구글 검색 엔진)
-   웹 아카이빙: 미래 사용 목적을 위해 장기 보관 용도로 웹에서 정보를 모은다.

    (ex. 미국 국회 도서관, EU 웹 아카이브)
-   웹 마이닝: 인터넷에서 유용한 지식 도출 가능

    (ex. 주주 총회 자료, 연차 보고서 등.)
-   웹 모니터링: 저작권, 상표권 침해되는 사례를 모니터링

    (ex. digimarc)  
    웹 크롤러의 복잡도는 데이터 규모에 따라 달라진다.



## 문제 이해 및 설계 범위 확정

<기본 알고리즘>

1.  URL 집합이 입력되면 URL 페이지를 다운로드
2.  다운받은 웹 페이지의 URL 추출
3.  추출한 URL을 다운로드할 URL 목록에 추가하고 1번 부터 반복


용도: 검색 인덱싱  
수집 수: 10억(1bilion)  
고려할 사항: 수정된 웹 페이지 고려, 5년간 저장, 중복 컨텐츠 무시


-   규모 확장성: 병행성을 활용하여 웹 크롤링을 효율적으로 할 수 있다.
-   안정성(robustness): 비정상적인 입력, 환경, 오류 등에 대응 할 수 있어야 한다.
-   예절: 짧은 시간에 너무 많은 요청을 보내면 안 된다.
-   확장성(excensibility): 새 콘텐츠를 쉽게 붙일 수 있어야 한다.




### 개략적 규모 추정

-   매달 10억개의 웹 페이지 다운로드
-   QPS = 10억(1bilion)/30일/24시간/3600초 ≒ 400pg/s
-   최대(peek)QPS = 2×QPS = 800
-   웹 페이지 평균 크기 500k 가정
-   10억 페이지×500k = 500TB/월.
-   5년간→30PB




## 개략적 설계안 제시 및 동의
![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fn7Ljb%2FbtsImEAv6CZ%2Fl9dU0zLLYjUgfBrxxBSfa0%2Fimg.png)
<br><br>

#### 시작 URL 집합
크롤링의 시작점. 크롤러가 많은 링크를 탐색할 수 있도록 고르는 것이 중요하다. 보통 전체 URL 공간을
부분집합으로 나눈다. <br>

정답은 없다. <br>

#### 미수집 URL 저장소
현대 크롤러의 크롤링 상태는 (1) 다운로드 할 URL, (2) 다운로드 된 URL로 나눈다.<br>
이 중 (1)을 관리하는 컴포넌트를 미수집 URL 저장소(URL Frontier)라고 부른다.
*FIFO Queue*라 생각하자.
<br>

#### HTML 다운로더
웹 페이지를 다운로드 하는 컴포넌트로 미수집 URL 저장소(URL Frontier)가 제공
<br><br>

#### 도메인 이름 변환기
HTML 다운로더는 도메인 이름 변환기를 이용하여 URL 의 IP 주소를 알아낸다.
<br>

#### 콘텐츠 파서
크롤링 서버의 속도를 고려하여 독립된 컴포넌트로 구현한다.
<br>

#### 중복 컨텐츠?
두 HTML 문서의 문자열 비교하는 방법이 있겠다. 혹은 웹 페이지 해시 값 비교가 있다.
<br>

#### 콘텐츠 저장소
HTML 문서를 저장하는 시스템으로
- 대부분 디스크에 저장
- 인기 있는 콘텐츠는 메모리에 저장
<br>으로 구현한다.
<br>

#### URL 추출기
상대 경로는 절대 경로로 변경한다.<br>

#### URL 필터
오류가 발생하거나 예외 시킬 URL을 크롤링 대상에서 배제하는 역할<br>

#### 이미 방문한 URL?
블룸 필터나 해시 테이블로 구현한다.<br>

#### URL 저장소
이미 방문한 URL 을 보관하는 저장소 <br>

#### ∴ 작업 흐름
1. 시작 URL을 미수집 URL 저장소에 저장
2. HTML 다운로더는 URL 목록을 가져온다.
3. HTML 다운로더는 도메인 이름 변환기로 IP 주소를 추출하고, 웹 페이지 다운받는다.
4. 콘텐츠 파서는 다운한 HTML 페이지를 파싱하여 검증한다.
5. 중복 컨텐츠인지 확인한다.
6. 페이지가 이미 있는지 확인한다.
- 저장소에 있는 컨텐츠면 버린다.
- 저장소에 없는 컨텐츠면 저장소 저장 후 URL 추출기로 전달한다.
7. URL 추출기는 링크를 골라낸다.
8. URL 필터로 전달
9. 남은 URL 은 중복 URL 판별 단계로 전달
10. URL 저장소에 보관된 URL 인지 확인
11. 저장소에 없는 URL은 URL 저장소와 미수집 URL 저장소에 저장 및 전달

<br>

## 상세 설계
#### DFS 냐 BFS 냐
BFS 를 선호한다. FIFO Queue 를 사용한다. 그러나 문제점이 있다.
- 한 페이지에서 나오는 링크는 대부분 같은 서버로 되돌아 간다. 이 때, 링크를 병렬 처리 하면 과부하 걸린다.
<br>이를 *예의 없는 크롤러*로 간주한다.
- 표준 BFS 알고리즘은 URL 간의 우선순위가 없다. 그러나 페이지 순위, 트래픽 양, 등을 통해 우선
순위를 둬야 한다.
<br>

#### 미수집 URL 저장소
미수집 URL 저장소를 사용하면 해결할 수 있다. URL 사이의 우선순위와 신선도를 구별하는
크롤러를 구현할 수 있다.

##### 예의
짧은 시간에 너무 많은 요청을 보내면 안 된다. DoS 공격으로 오해받을 수 있기 떄문이다.
따라서 *한 번에 한 페이지 요청* 하는 것이 중요하다.
<br>웹 사이트의 hostname 과 작업 스레드 사이의 관계를 유지하면 된다.
<br>다운로드 스레드는 FIFO 큐를 가지고 있기 때문에 큐에서 꺼낸 URL 만 다운로드 한다.
<br><br>

![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbpV7Af%2FbtsIpv4UAb5%2FJh6kDYMWX0rjLZpsGSS3uk%2Fimg.png)
- 큐 라우터: 같은 호스트에 속한 URL 은 같은 큐로 가도록 보장
- 매핑 테이블: 호스트 이름과 큐 사이의 관계를 보관하는 테이블
- FIFO 큐(b1~bn): 같은 호스트에 속한 URL 을 한 큐에 저장
- 큐 선택기: 큐를 순회하며 URL 을 꺼내고 다운로드 하도록 지정한 작업 스레드에 전달
- 작업 스레드: 전달된 URL 을 다운로드. 일정 지연 시간 둘 수 있다.

<br>

##### 우선 순위
유용성에 따라 우선 순위를 나눌 때는 페이지랭크, 트래픽 양, 갱신 빈도 등 척도를 세울 수 있다.
<br>
![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbAypfj%2FbtsIqysJ6hT%2FMojMTk4zW7otLda7PFPSn1%2Fimg.png)
<br>
- 순위결정장치(prioritizer): URL 을 입력 받아 우선 순위 계산
- 큐(f1,···fn): 우선순위 별로 큐 하나씩 할당
- 큐 선택기: 임의 큐에서 처리할 URL 꺼내는 역할

위의 그림을 이어서 반영한 설계를 보자.<br>

![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcLm87K%2FbtsIpHcVtJn%2FCq3KTm7phygdpLJjk4OKTk%2Fimg.png)
- 전먼 큐(front queue): 우선순위 결정 과정 처리
- 후면 큐(back queue): 크롤러의 politeness 를 보증
<br><br>

##### 신선도
웹 페이지는 수시로 변경되기 때문세 신선도를 보장해야 한다. 주기적으로 재수집해야 할 필요가 있다.
그러나 이 것도 전략이 필요하다.
- 웹 페이지 update history 활용
- 우선순위를 활용하여, 중요 페이지를 자주 재수집

<br>

##### 미수집 URL 저장소를 위한 지속적 저장장치
URL의 대부분은 디스크에 두고, 메보리 버퍼에 큐를 둘 것이다. 버퍼 데이터는 주기적으로 디스크에 
기록함으로 규모 확장성 측면을 절충한다.
<br><br>

#### HTML 다운로더
HTML 다운로더는 HTTP 프로토콜로 웹 페이지를 받는다.

###### Robots.txt
로봇 제외 프로토콜이라고도 불린다. 웹 사이트와 크롤러가 소통하는 표준 방법이다.
<br>파일에는 크롤러가 수집해도 되는 페이지 목록이 들어가 있다. 크롤링 하기 전에 파일 규칙을
확인하게 된다.
<br>Robots.txt 파일을 주기적으로 다운 받아 캐시에 저장할 것이다. 
<br><br>

###### 성능 최적화
HTML 다운로더에 사용할 수 있는 성능 최적화 기법은 다음과 같다.
1. 분산 크롤링
- 크롤링을 여러 서버에 분산시키는 것이다. URL 공간을 작게 분할하여 각 서버가 일부를 다운로드 담당으로 맡게 된다.
2. 도메인 이름 변환 결과 캐시
- 도메인 이름 변환기(DNS Resolver)는 DNS 요청과 결과 수신의 동기적 특성때문에 크롤러 성능의 병목이 된다.
- 스레드가 DNS 요청 처리를 하고 있으면 다른 작업은 블락된다. DNS 조회로 도메인 이름과 IP 주소 관계를 캐시에 보관한 후,
크론 잡을 갱신하면 성능을 높일 수 있다.
3. 지역성
- 서버를 지역으로 분산하는 방법이다. 크롤 서버, 캐시, 큐, 저장소 등의 컴포넌트에 적용 가능
4. 짧은 타임아웃
- 서버 미응답시 크롤러는 작업 중단하고 다음 페이지로 넘어간다.
5. 안정성
- 안정 해시(consistent hashing): 서버 부하를 분산시키기 위해 적용하는 기술이다. 안정 해시를 통해 
다운로더 서버를 쉽게 추가/삭제가 가능
6. 크롤링 상태 및 수집 데이터 저장: 장애가 발생해도 복구 할 수 있도록 주기적으로 저장하는 것
7. 예외 처리(exception handling): 예외 발생 시에도 유연하게 대처해야 함
8. 데이터 검증(data validation): 시스템 오류 방지 위한 수단

###### 확장성
새로운 콘텐츠를 쉽게 적용할 수 있어야 한다.
- PNG 다운로더: PNG 파일 다운로드 플러그인
- 웹 모니터: 웹 모니터링으로 저작권, 상표권을 보호하는 모듈



###### 문제 있는 콘텐츠 감지 및 회피
1. 중복 컨텐츠: 웹 콘텐츠의 30%는 중복이므로 해시나 체크섬으로 탐지한다.
2. 거미 덫: 무한 루프에 빠뜨리는 웹 페이지로 URL 최대 길이를 제한으로 방지 가능. 
혹은, 수작업으로 감지해야 한다.
3. 데이터 노이즈: 가치 없는 웹 페이지는 피해야 한다.

<br><br>

## 마무리
좋은 크롤러가 가져야 하는 특성은 규모 확장성, 예의, 확장성, 안정성 등이 있다.
다음을 추가로 논의해 보면 좋다.
- 서버 측 렌더링: 자바스크립트, AJAX 로 링크를 즉석으로 만들게 된다. 그대로 다운받아 파싱하면 동적 생성 링크는 발견할 수 없다.
이를 서버 측 렌더링을 통해 해결할 수 있다.
- 원치 않는 페이지 필터링: 스팸 반지 컴포넌트를 풀어 필터링한다.
- 데이터베이스 다중화 및 샤딩: 다중화(replication), 샤딩같은 기법으로 데이터 계층의 가용성, 규모확장성,
안정성이 향상된다.
- 수평적 규모 확장성: 무상태 서버로 만들어 규모 확장성을 이룬다.
- 가용성, 일관성, 안정성
- 데이터 분석 솔루션

***

# 10장 알림 시스템 설계
알림 시스템은 정보를 *비동기적*으로 제공한다. 알림 시스템은 모바일 푸시 알림부터 SMS, 이메일로 분류할 수 있다.
<br>

## 문제 이해 및 설계 범위 확정
- 푸시, SMS, 이메일
- 연성 실시간 시스템일 것. 약간의 지연은 가능
- ios, 안드로이드, 랩탑/데스크탑
- 클라이언트, 서버 양측 다 스케줄링 가능
- 알림 거부도 가능해야 함
- 하루 천만건 모바일 푸시 알림, 백만건 SMS, 5백만 건의 이메일
<br>

## 개략적 설계안 제시 및 동의 구하기
### 알림 유형별 지원 방안
![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FOpdGJ%2FbtsIpYyOm4J%2F84X7CB62Ua8XTKkjk44JK1%2Fimg.png)
- 알림 제공자(provider): 알림 요청을 만들어 푸시 알림 서비스로 보내는 주체다.<br>
애플 → APNS<br>안드로이드 → FCM<br>SMS → Twilio 등<br> E-Mail → Sendgrid 등
    - 단말 토큰: 알림 요청을 위한 고유 식별자
    - 페이로드: 알림 내용을 담은 JSON 형태의 딕셔너리

### 연락처 정보 수집 절차
알림을 보내기 위해서는 단말 토큰, 이메일 주소, 전화 번호 등이 필요하다. 처음 계정 등록 시 
API 서버는 다음 정보를 데이터베이스에 저장한다.<br>
이 때, 한 사람이 여러 단말을 가진다고 가정하여, 
이메일 주소와 전화번호는 user 테이블에, 단말 토큰은 device 테이블에 저장한다.
<br>


#### 개략적 설계안(초안)
    - 1~N 까지 서비스: 마이크로서비스나 크론잡의 형태로 과금 서비스, 배송 알림 서비스 등이 있다.
    - 알림 시스템: 1개 서버로 가정했을 때, 서비스 N 에 알림 전송 API 제공, 제3자 서비스에 페이로드를 만들어야 한다.
    - 제3자 서비스: 확장성을 유의해야 한다. 중국 같은 경우는 FCM을 사용할 수 없다.
    - IOS, 안드로이드, SMS, 이메일 단말: 사용자의 단말에서 수신해야 한다.
이는 다음과 같은 문제를 초래한다.
- SPOF: 1개의 서버밖에 없기 때문에
- 규모 확장성: 1개의 서버로 푸시 알림을 처리하므로 데이터베이스나 캐시 같은 컴포넌트의 규모를 개별적으로 늘릴 수 없다.
- 성능 병목: 트래픽이 몰릴 시간에 시스템 과부하 걸릴 수 있다.
<br>

#### 개략적 설계안(개선)
    - 데이터베이스와 캐시를 주 서버에서 분리한다.
    - 알림 서버를 증설, 자동으로 수평적 규모 확장이 이루어질 수 있도록 한다.
    - 메시지 큐를 이용해 시스템 컴포넌트 사이의 강한 결합 끊는다.
<br>

![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FtYpa3%2FbtsIpSMb6Su%2FS1o0DAwaG8GTKBJCgNdDm1%2Fimg.png)
- 1~N 서비스: API를 통해 알림 보낼 서비스
- 알림 서버:
  - 알림 전송 API: 스팸 방지를 위해 인증 클라이언트만 이용
  - 알림 검증: 이메일 주소 등의 기본 검증
  - 데이터베이스, 캐시 질의: 알림 포함시킬 데이터 갖고오는 기능
  - 알림 전송: 메시지 큐에 넣어 전송한다. 병렬적 처리 가능
- 캐시: 사용자 정보, 단말, 알림 템플릿 캐시
- 데이터베이스: 사용자, 알림 등 정보 저장
- 메시지 큐:시스템 컴포넌트 간 의존성 제거 역할.<br>
여러 알림 보내야 할 경우 메시지 버퍼 역할
- 작업 서버: 메시지 큐에서 제3자 서비스로 전달
- 제3자 서비스
- ios, 안드로이드, SMS, 이메일

**순서**
1. API 호출하여 알림 서버로 보낸다.
2. 메타 데이터를 캐시나 데이터베이스에서 가져온다.
3. 알림 서버는 전송할 알림에 맞는 이벤트를 큐에 넣는다.
4. 작업 서버는 메시지 큐에서 알림 이벤트 꺼낸다.
5. 작업 서버는 알림을 제3자 서비스로 보낸다.
6. 제3자 서비스는 사용자 단말로 알림을 보낸다.



## 상세 설계
### 안정성
#### 데이터 손실 방지
알림 전송 시 알림이 소실되면 안 된다. 따라서 알림 데이터를 데이터베이스에 보관하고 재시도 매커니즘을 구현한다.
<br>

#### 알림 중복 전송 방지
빈도수를 줄이는 것이 목표로 한다.
- 알림 도착시 이벤트 ID를 검사하여 중복 체크를 하는 방법으로 알림을 발송한다.

#### 추가로 필요한 컴포넌트 및 고려사항
###### 알림 템플릿
템플릿을 만들면 오류를 최소화하고 형식을 일관성 있게 맞출 수 있다.

###### 알림 설정
알림 설정을 상세히 조정하여 수신을 조정할 수 있다.

###### 전송률 제한
사용자가 받을 수 있는 알림을 제한한다.

###### 재시도 방법
알림 실패시 재시도 전용 큐에 넣거나 문제가 반복 시에 개발자에게 통지한다.

###### 푸시 알림과 보안
IOS와 안드로이드의 경우 알림 전송 API 를 appKey 와 appSecret 으로 보안을 유지한다.

###### 큐 모니터링
알림 시스템 모니터링시 중요 메트릭 하나는 큐에 쌓인 알림의 갯수이다. 수가 너무 커지면
이벤트를 빠르게 처리하지 못하므로 작업 서버를 증설하는게 좋다.

###### 이벤트 추적
데이터 분석 서비스는 이벤트 추적을 보통 제공한다.

##### 수정된 설계안
- 알림 서버에 인증(authentication), 전송률 제한(rate-limiting) 추가
- 전송 실패시 재시도 기능 추가. 지정된 횟수만큼 재시도 시도
- 전송 템플릿을 사용하여 알림 생성을 단순화하고 일관성 유지
- 모니터링 추적 시스템을 추가하여 시스템 상태 확인, 추후 시스템을 개선할 수 있도록 함

## 마무리
- 안정성(reliability): 메시지 전송 실패율을 낮추기 위해 재시도 메커니즘 도입
- 보안: appKey, appSecret 을 통해 인증된 클라이언트에게만 전송
- 이벤트 추적 및 모니터링: 알림 전송 단계마다 이벤트 추적과 모니터링 할 수 있는 시스템 통합
- 사용자 설정: 사용자가 알림 수신을 조정할 수 있게 함
- 전송률 제한: 사용자에게 알림 보내는 빈도를 제한

<br><br>

## 자료, 참조
- Alex Xu, (2021). 가상 면접 사례로 배우는 대규모 시스템 설계 기초, 인사이트

