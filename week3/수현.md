# 5장. 안정 해시 설계

## 해시 키 재배치(rehash) 문제
N개의 캐시 서버가 있을 때, 데이터를 균등하게 분배하기 위해 보편적으로 해시 함수를 사용한다.
```text
serverIndex = hash(key) % N
```
![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/8fab037a-7292-44cc-b920-abdb2c87fcb7)

이 방법은 서버 풀의 크기가 고정되었을 때 데이터 분포가 균등하게 잘 동작한다. 그러나 서버를 추가하거나 삭제하면, 키에 대한 해시값은 변하지 않지만 나머지 연산을 적용하여 계산한 서버 인덱스 값이 달라진다. 즉, 서버가 죽으면 캐시 클라이언트가 데이터가 없는 엉뚱한 서버에 접속하는 대규모 캐시 미스가 발생할 수 있다.

## 안정 해시
안정 해시는 해시 테이블 크기가 조정될 때 평균적으로 오직 \(k\) (키의 개수) / \(n\) (슬롯의 개수) 만큼의 키만 재배치하는 해시 기술이다. 대부분의 전통적인 해시 테이블은 슬롯의 수가 바뀌면 대부분의 키를 재배치한다.

## 해시링
![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/b1edbfad-b8ec-4f81-a26b-a82fb2605b6e)

해시 공간을 양쪽이 이어지게 구부려 링 모양이 되면 이를 해시 링이라고 한다. 이 해시 링 위에 서버를 배치한다. 이를 통해 서버 조회, 서버 추가, 서버 제거 로직이 이루어진다.

## 해시키
![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/4455e652-6eec-422c-8cb5-ebc1a7cd3c4a)
key0, key1, key2, key3 또한 해시 링 위의 어떤 지점에 배치할 수 있다.

### 서버 조회
어떤 키가 저장되는 서버는 해당 키의 위치로부터 시계방향으로 링을 탐색해 나가면서 처음으로 만나는 서버이다. key0은 서버 0에 저장되고, key1은 서버 1, key2는 서버 2, key3은 서버 3에 저장된다.

### 서버 추가
서버를 추가하더라도 키 중 일부만 재배치하면 된다. 새로운 서버 4가 추가된 뒤에 key0만 재배치됨을 알 수 있다. key1, key2, key3은 같은 서버에 남는다. 서버 4가 추가되기 전, key0은 서버 0에 저장되어 있었다. 하지만 서버 4가 추가된 뒤에 key0은 서버 4에 저장될 것이다. 이는 key0의 위치에서 시계방향으로 순회했을 때 처음으로 만나게 되는 서버가 서버 4이기 때문이다. 다른 키들은 재배치되지 않는다.

### 서버 제거
하나의 서버가 제거되면 키 중 일부만 재배치된다. 서버 1이 삭제되었을 때 key1만이 서버 2로 재배치됨을 알 수 있다. 나머지 키에는 영향이 없다.

### 기존 구현법의 두 가지 문제
안정 해시 알고리즘은 처음에 MIT에서 제안되었다.
* 서버와 키를 균등분포 해시 함수를 사용해 해시링에 배치한다.
* 키의 위치에서 링을 시계방향으로 탐색하다가 만나는 최초의 서버가 키가 저장될 위치이다.

하지만 이는 서버가 추가되거나 삭제될 때 파티션의 크기를 균등하게 유지하는 것이 불가능하다. 또한, 키의 균등분포를 달성하기 어렵다는 점이 있다.

## 가상 노드
가상 노드란 실제 노드 또는 서버를 가리키는 노드를 의미한다. 하나의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있다. 따라서 각 노드는 하나가 아닌 여러 개의 파티션을 관리해야 한다. 가상 노드의 개수를 늘리면 키의 분포가 균등해진다. 이는 표준 편차(데이터가 얼마나 고르게 퍼져나가는지)가 작아져 데이터가 고르게 분포되기 때문이다. 대신 가상 노드를 늘리면 저장할 공간이 더 많이 필요하기 때문에 타협적인 결정이 필요하다.

## 안정 해시의 이점
* 서버가 추가되거나 삭제될 때 재배치되는 키의 수가 최소화된다.
* 데이터가 보다 균등하게 분포하게 되므로 수평적 규모 확장성을 달성하기 쉽다.
* 핫스팟 키 문제를 줄인다. 특정한 샤드(shard)에 대한 접근이 지나치게 빈번하면 서버 과부하 문제가 생길 수 있다. 안정 해시는 데이터를 좀 더 균등하게 분배하므로 이러한 문제가 생길 가능성을 줄인다.

# 6장. 안정 해시 설계
키-값 저장소는 키-값 데이터베이스라고도 불리는 비관계형 데이터베이스를 의미한다. 따라서 이 저장소에 저장되는 값은 고유 식별자를 키로 가져야 한다. 키와 값 사이의 이런 관계를 "키-값" 쌍이라고 저장한다.
* 키: 키는 항상 유일해야 하며 해당 키에 매달린 값은 키를 통해서만 접근할 수 있다. 키는 일반 텍스트, 해시 값일 수도 있다. 성능을 높이려면 키는 짧을수록 좋다.
* 값: 값은 문자열, 리스트, 객체일 수 있으며 어느 값이 오든 상관없다.

## 단일 서버 키-값 저장소
가장 직관적인 방법은 키-값 쌍 전부를 메모리에 해시테이블로 저장하는 것이다. 다만 이 방법은 빠른 속도가 나오지만, 모든 데이터를 메모리 안에 두는 것이 힘들다는 단점이 있다.

이 문제를 해결하기 위해 쓰는 방법(그러나 이 방법도 한계치가 있으므로 **분산 키-값 저장소**를 쓰는 것을 추천):
> 데이터 압축
> 자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장

## 분산 키-값 저장소
분산 키-값 저장소는 키-값 쌍을 여러 서버에 분산시킨 탓에 분산 해시 테이블이라고도 불린다.

### CAP 정리
CAP 정리는 데이터 일관성, 가용성, 파티션 감내라는 세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것이 불가능하다는 정리이다.

* 데이터 일관성: 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 상관없이 같은 데이터를 보아야 한다.
* 가용성: 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.
* 파티션 감내: 네트워크에 파티션이 생기더라도 시스템은 계속 동작해야 한다는 것을 의미한다.

이들 가운데 두 가지를 충족하려면 하나는 포기해야 한다는 것을 의미한다.

![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/9dc40b4b-d2f7-4a08-85ab-9789d43c614b)

실제 이상적 상태에서는 네트워크가 파티션 되는 상황이 일어나지 않아 데이터 일관성과 가용성 둘 다 만족된다. 하지만 실제 분산 시스템은 파티션 문제를 피할 수 없다. 따라서 일관성과 가용성 사이에서 하나를 선택해야 하는 상황이 온다.

![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/f33593d0-080e-40d5-92a2-5731f8695dc4)

* 가용성 대신 일관성을 선택한다면? CP시스템으로 서버 사이에 생길수 있는 불일치를 피하기 위해 쓰기 노드를 중단시킨다. => 은행권시스템 대다수
* 일관성 대신 가용성을 선택한다면? AP시스템으로 예전 데이터를 반환할 위험이 있더라도 계속 읽기 연산을 허용해야한다.

## 시스템 컨포넌트 
키-값 저장소 즉 다이나모 카산드라 빅테이블의 사례를 참고하였다.

### 데이터 파티션
대규모 애플리케이션의 경우, 한 대 서버에 모두 욱여넣는것을 불가능하다. 따라서 데이터를 작은 파티션으로 분할한 다음 여러 대 서버에 저장한다.
이때 따져야하는 중요한 문제가 두가지 있다.
* 데이터를 여러 서버에 고르게 분산할 수 있는가?
* 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가?

=> 이런 문제를 풀기위해서는 "안정해시" 기술이 적합하다. 
#### 안정해시를 사용하여 데이터 파티션을 하면 좋은 이유
* 규모 확장 자동화: 시스템 부하에 맞춰 자동으로 서버가 추가되거나 삭제된다.
* 다양성: 각 서버의 용량에 맞게 가상노드의 수를 조정할 수 있다. 고성능 서버는 더 많은 가상 노드를 갖도록 설정 가능능

### 데이터 다중화
높은 가용성과 안정성을 확보하기 위해서는 데이터를 N(튜닝 가능한 값)개 서버에 비동기적으로 다중화할 필요가 있다.
![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/c5a9c442-62a8-4fb1-add0-a84c8fe08bd5)
가상 노드를 사용할 경우 N개의 노드가 대응될 실제 물리 서버의 개수가 N보다 작아질 수 있다. 
이 문제를 피하려면 노드를 선택할 때 같은 물리 서버를 중복 선택하지 않도록 해야 한다.
같은 데이터 센터에 속한 노드는 문제를 동시에 겪을 가능성이 있다. 따라서 안정성을 담보하기 위해 데이터의 사본은 다른 센터의 서버에 보관하고, 센터들은 고속 네트워크로 처리한다.

### 일관성
여러 노드에 다중화한 데이터는 적절히 동기화 되어야 한다. 정족수의 합 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다.
* 일관성 모델
* 비 일관성 해소 기법: 데이터 버저닝
* 장애 처리
* 장애 감지
* 일시적 장애 처리
* 영구 장애 처리
* 데이터 센터 장애 처리

### 시스템 아키텍처 다이어그램
클라이언트는 키-값 저장소가 제공하는 두 가지 단순한 API, 즉 get(key) 및 put(key, value)와 통신한다.
중재자(coordinator)는 클라이언트에게 키-값 저장소에 대한 프락시(proxy) 역할을 하는 노드다.
노드는 안정 해시(consistent hash)의 해시 링(hash ring) 위에 분포한다.
노드를 자동으로 추가 또는 삭제할 수 있도록, 시스템은 완전히 분산된다(decentralized).
데이터는 여러 노드에 다중화된다.
모든 노드가 같은 책임을 지므로, SPOF(Single Point of Failure)는 존재하지 않는다.

### 쓰기 경로
![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/daf21c48-4238-45c4-92b3-0398379e1e8d)

① 쓰기 요청이 커밋 로그(commit log) 파일에 기록된다.
② 데이터가 메모리 캐시에 기록된다.
③ 메모리 캐시가 가득차거나 사전에 정의된 어떤 임계치에 도달하면 데이터는 디스크에 있는 SSTable에 기록된다.

SSTable은 Sorted-String Table의 약어로, <키, 값>의 순서쌍을 정렬된 리스트 형태로 관리하는 테이블이다.

### 읽기 경로

![image](https://github.com/moonsoo20/system-design-interview/assets/98132695/40016509-682b-4ecc-bf87-2c5ee1d61570)

# 데이터가 메모리에 있는 경우

① 데이터가 메모리에 있는지 검사한다. 있으면 클라이언트에게 바로 반환한다.

# 데이터가 메모리에 없을 경우

① 데이터가 메모리에 있는지 검사한다. 없으면 ②로 간다.
② 데이터가 메모리에 없으므로 블룸 필터를 검사한다.
③ 블룸 필터를 통해 어떤 SSTable에 키가 보관되어 있는지 알아낸다.
④ SSTable에서 데이터를 가져온다.
⑤ 해당 데이터를 클라이언트에게 반환한다.

어느 SSTable에 찾는 키가 있는지 찾아내기 위해 Bloom filter가 흔히 사용된다.


  





