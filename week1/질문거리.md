1. Stateless한 HTTP 에서 로그인을 어떻게 구현할까?
   -> JWT

2. 로드밸런서는 scale up의 방안이 될 수도 있을까?
   -> scale out의 방안이 됨, scale up도 가능함?

3. 데이터베이스 다중화 데이터베이스를 나누는 경우 실시간 업데이트에 대해서 지연시간이 발생하지 않는가?
   -> master 에 쓰여진 데이터가 slave에 commit 까지 된 후에 해당 데이터를 읽을 수 있게 하기
   -> 정합성이 중요한 데이터는 slave대신 master에서 읽어오기

4. 메시지큐 메시지큐를 받는 서버에 일시적 장애가 생겨 이미 수신한 메시지를 정상적으러처리하지 못한 경우 이 요청은 어떻게 되는가?
   -> Message Queue가 정상적으로 완료되었다는 응답을 받아야 끝

5. 샤딩에서 핫스팟 키를 해결하기 위한 방법은?
   -> Shad키를 재할당해서 쪼개거나, 추가하는 방식으로 해결
   -> Replica를 만들어서 로드밸런싱

6. 메시지 큐가 다운되면 어떻게 되는가? (p.25 그림에서)
   -> 서버가 죽게되면 메세지큐는 남아있다.

7. sticky session이 로드밸런서에게 과부하를 주는 이유는 로드밸런서가 접속 정보를 저장하고 있어서 인가? (p.18)
   -> 그렇다.

8. 로드밸런서가 sticky session을 유지해주는 기간은 얼마일까?
   -> 정하기 나름.

9. sticky session을 로드밸런서가 어떤식으로 처리하는지?
   -> cookie에 저장, ip hash 방식
   -> L7 cookie, L4 hash를 사용하는데 L7을 주로 사용함
   -> TCP L7, UDP L4

10. NoSQL이 규모 확장이 간편한 이유는?
    -> 테이블 단위로 나뉘어 있는 RDB와는 다르게 join을 사용할 필요가 없으므로.

11. DNS, 로드밸런서의 역할?
    -> IP주소를 수기로 입력하는 대신 대표이름 사용
    -> Load Balancer는 부하를 분산해줌

12. 캐시를 효율적으로 사용하는 방법? 캐시히트를 높히는 방법?
    -> 서비스에 맞는 캐시정책을 잘 정한다.
    -> Client에 넘길 수 있는 Cache는 넘긴다.
